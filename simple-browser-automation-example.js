const { chromium } = require('playwright');
const fs = require('fs');
const readline = require('readline');

/**
 * ÂÖÉÁ¥†Á±ªÂûãÂÆö‰πâÂíåÊ†áËÆ∞Á≥ªÁªü
 */
const ElementTypes = {
    BUTTON: {
        name: 'button',
        priority: 100,
        color: '#ff4444',
        bgColor: 'rgba(255, 68, 68, 0.15)',
        selector: 'button, input[type="button"], input[type="submit"], input[type="reset"], [role="button"], .btn, .button',
        description: 'ÊåâÈíÆÂÖÉÁ¥†',
        interactionType: 'clickable'
    },
    INPUT: {
        name: 'input',
        priority: 95,
        color: '#ff8800',
        bgColor: 'rgba(255, 136, 0, 0.15)',
        selector: 'input:not([type="button"]):not([type="submit"]):not([type="reset"]), textarea, [contenteditable="true"], [role="textbox"]',
        description: 'ËæìÂÖ•Ê°ÜÂÖÉÁ¥†',
        interactionType: 'editable'
    },
    LINK: {
        name: 'link',
        priority: 85,
        color: '#00cc44',
        bgColor: 'rgba(0, 204, 68, 0.15)',
        selector: 'a[href], [role="link"]',
        description: 'ÈìæÊé•ÂÖÉÁ¥†',
        interactionType: 'navigable'
    },
    SELECT: {
        name: 'select',
        priority: 90,
        color: '#0088ff',
        bgColor: 'rgba(0, 136, 255, 0.15)',
        selector: 'select, input[type="checkbox"], input[type="radio"], [role="checkbox"], [role="radio"], [role="combobox"]',
        description: 'ÈÄâÊã©Êéß‰ª∂',
        interactionType: 'selectable'
    },
    INTERACTIVE: {
        name: 'interactive',
        priority: 70,
        color: '#8844ff',
        bgColor: 'rgba(136, 68, 255, 0.15)',
        selector: '[onclick], [onchange], [data-click], .clickable, [tabindex]:not([tabindex="-1"])',
        description: '‰∫§‰∫íÂÖÉÁ¥†',
        interactionType: 'clickable'
    },
    CUSTOM: {
        name: 'custom',
        priority: 60,
        color: '#ffcc00',
        bgColor: 'rgba(255, 204, 0, 0.15)',
        selector: '[role="tab"], [role="menuitem"], [role="treeitem"], [role="gridcell"]',
        description: 'Ëá™ÂÆö‰πâ‰∫§‰∫íÂÖÉÁ¥†',
        interactionType: 'clickable'
    }
};

class PageStateMonitor {
    constructor(page) {
        this.page = page;
        this.currentState = {
            url: '',
            title: '',
            domHash: '',
            timestamp: 0,
            isLoading: false,
            hasNewContent: false
        };
        this.stateHistory = [];
        this.changeListeners = [];
        this.monitoringActive = false;
        this.lastDOMSnapshot = null;
    }

    /**
     * ÂêØÂä®È°µÈù¢Áä∂ÊÄÅÁõëÊéß
     */
    async startMonitoring() {
        if (this.monitoringActive) return;
        
        console.log('üîÑ ÂêØÂä®È°µÈù¢Áä∂ÊÄÅÁõëÊéßÂô®...');
        
        // ÁõëÂê¨È°µÈù¢ÂØºËà™‰∫ã‰ª∂
        this.page.on('domcontentloaded', () => this.handlePageChange('domcontentloaded'));
        this.page.on('load', () => this.handlePageChange('load'));
        this.page.on('framenavigated', () => this.handlePageChange('framenavigated'));
        
        // ÂÆöÊúüÊ£ÄÊü•DOMÂèòÂåñ
        this.domCheckInterval = setInterval(() => {
            this.checkDOMChanges().catch(console.error);
        }, 2000);
        
        this.monitoringActive = true;
        
        // Ëé∑ÂèñÂàùÂßãÁä∂ÊÄÅ
        await this.updateCurrentState();
        
        console.log('‚úÖ È°µÈù¢Áä∂ÊÄÅÁõëÊéßÂô®Â∑≤ÂêØÂä®');
    }

    /**
     * Â§ÑÁêÜÈ°µÈù¢ÂèòÂåñ‰∫ã‰ª∂
     */
    async handlePageChange(eventType) {
        console.log(`üîÑ Ê£ÄÊµãÂà∞È°µÈù¢‰∫ã‰ª∂: ${eventType}`);
        
        // Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆö
        await this.waitForPageStability();
        
        // Êõ¥Êñ∞Áä∂ÊÄÅ
        const oldState = { ...this.currentState };
        await this.updateCurrentState();
        
        // ÈÄöÁü•ÁõëÂê¨Âô®
        await this.notifyStateChange(oldState, this.currentState, eventType);
    }

    /**
     * Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆö
     */
    async waitForPageStability(timeout = 10000) {
        try {
            console.log('‚è≥ Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆö...');
            
            // Á≠âÂæÖDOMÂä†ËΩΩÂÆåÊàê
            await this.page.waitForLoadState('domcontentloaded', { timeout: 5000 });
            
            // Á≠âÂæÖÁΩëÁªúÁ©∫Èó≤
            await this.page.waitForLoadState('networkidle', { timeout: 5000 });
            
            // È¢ùÂ§ñÁ≠âÂæÖÁ°Æ‰øùÂä®ÊÄÅÂÜÖÂÆπÂä†ËΩΩ
            await this.sleep(1500);
            
            console.log('‚úÖ È°µÈù¢Â∑≤Á®≥ÂÆö');
        } catch (error) {
            console.warn('‚ö†Ô∏è Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆöË∂ÖÊó∂:', error.message);
        }
    }

    /**
     * Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢Áä∂ÊÄÅ
     */
    async updateCurrentState() {
        try {
            const pageInfo = await this.page.evaluate(() => {
                // ËÆ°ÁÆóDOMÁªìÊûÑÂìàÂ∏å
                const getDOMHash = () => {
                    const elements = document.querySelectorAll('*');
                    let hash = 0;
                    for (let i = 0; i < Math.min(elements.length, 100); i++) {
                        const el = elements[i];
                        const str = el.tagName + (el.id || '') + (el.className || '');
                        for (let j = 0; j < str.length; j++) {
                            const char = str.charCodeAt(j);
                            hash = ((hash << 5) - hash) + char;
                            hash = hash & hash; // ËΩ¨Êç¢‰∏∫32‰ΩçÊï¥Êï∞
                        }
                    }
                    return hash.toString();
                };

                return {
                    url: window.location.href,
                    title: document.title,
                    domHash: getDOMHash(),
                    timestamp: Date.now(),
                    isLoading: document.readyState !== 'complete',
                    elementCount: document.querySelectorAll('*').length,
                    interactiveElementCount: document.querySelectorAll(
                        'button, input, a, select, textarea, [onclick], [role="button"], [role="link"], [tabindex]'
                    ).length
                };
            });

            // Ê£ÄÊµãÂèòÂåñ
            const hasChanged = this.hasSignificantChange(pageInfo);
            
            if (hasChanged) {
                this.stateHistory.push({ ...this.currentState });
                if (this.stateHistory.length > 10) {
                    this.stateHistory = this.stateHistory.slice(-10);
                }
                
                console.log(`üîÑ È°µÈù¢Áä∂ÊÄÅÊõ¥Êñ∞: ${pageInfo.url}`);
                console.log(`üìä ÂÖÉÁ¥†Êï∞Èáè: ${pageInfo.elementCount} (‰∫§‰∫íÂÖÉÁ¥†: ${pageInfo.interactiveElementCount})`);
            }

            this.currentState = {
                ...pageInfo,
                hasNewContent: hasChanged
            };

            return hasChanged;

        } catch (error) {
            console.error('‚ùå Êõ¥Êñ∞È°µÈù¢Áä∂ÊÄÅÂ§±Ë¥•:', error.message);
            return false;
        }
    }

    /**
     * Ê£ÄÊµãÈáçÂ§ßÂèòÂåñ
     */
    hasSignificantChange(newState) {
        const current = this.currentState;
        
        // URLÂèòÂåñ
        if (current.url !== newState.url) {
            console.log(`üåê URLÂèòÂåñ: ${current.url} ‚Üí ${newState.url}`);
            return true;
        }
        
        // Ê†áÈ¢òÂèòÂåñ
        if (current.title !== newState.title) {
            console.log(`üìÑ Ê†áÈ¢òÂèòÂåñ: "${current.title}" ‚Üí "${newState.title}"`);
            return true;
        }
        
        // DOMÁªìÊûÑÂèòÂåñ
        if (current.domHash !== newState.domHash) {
            console.log(`üîÑ DOMÁªìÊûÑÂèòÂåñÊ£ÄÊµã`);
            return true;
        }
        
        // ÂÖÉÁ¥†Êï∞ÈáèÈáçÂ§ßÂèòÂåñ
        const elementChange = Math.abs(newState.elementCount - current.elementCount);
        if (elementChange > 50) {
            console.log(`üìä ÂÖÉÁ¥†Êï∞ÈáèÈáçÂ§ßÂèòÂåñ: ${current.elementCount} ‚Üí ${newState.elementCount}`);
            return true;
        }
        
        return false;
    }

    /**
     * Ê£ÄÊü•DOMÂÜÖÂÆπÂèòÂåñ
     */
    async checkDOMChanges() {
        try {
            const snapshot = await this.page.evaluate(() => {
                const getVisibleText = () => {
                    const walker = document.createTreeWalker(
                        document.body,
                        NodeFilter.SHOW_TEXT,
                        {
                            acceptNode: (node) => {
                                const parent = node.parentElement;
                                if (!parent) return NodeFilter.FILTER_REJECT;
                                
                                const style = window.getComputedStyle(parent);
                                if (style.display === 'none' || style.visibility === 'hidden') {
                                    return NodeFilter.FILTER_REJECT;
                                }
                                
                                return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                            }
                        }
                    );
                    
                    let text = '';
                    let node;
                    while (node = walker.nextNode()) {
                        text += node.textContent.trim() + ' ';
                    }
                    return text.substring(0, 5000); // ÈôêÂà∂ÈïøÂ∫¶
                };

                return {
                    visibleText: getVisibleText(),
                    interactiveCount: document.querySelectorAll(
                        'button:not([disabled]), input:not([disabled]), a[href], select:not([disabled]), [onclick], [role="button"]'
                    ).length,
                    timestamp: Date.now()
                };
            });

            if (this.lastDOMSnapshot) {
                const textDiff = snapshot.visibleText !== this.lastDOMSnapshot.visibleText;
                const countDiff = Math.abs(snapshot.interactiveCount - this.lastDOMSnapshot.interactiveCount) > 2;
                
                if (textDiff || countDiff) {
                    console.log('üîÑ Ê£ÄÊµãÂà∞DOMÂÜÖÂÆπÂèòÂåñ');
                    await this.updateCurrentState();
                }
            }

            this.lastDOMSnapshot = snapshot;

        } catch (error) {
            console.warn('‚ö†Ô∏è DOMÂèòÂåñÊ£ÄÊü•Â§±Ë¥•:', error.message);
        }
    }

    /**
     * Ê∑ªÂä†Áä∂ÊÄÅÂèòÂåñÁõëÂê¨Âô®
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }

    /**
     * ÈÄöÁü•Áä∂ÊÄÅÂèòÂåñ
     */
    async notifyStateChange(oldState, newState, eventType) {
        for (const listener of this.changeListeners) {
            try {
                await listener(oldState, newState, eventType);
            } catch (error) {
                console.error('‚ùå Áä∂ÊÄÅÂèòÂåñÁõëÂê¨Âô®ÈîôËØØ:', error.message);
            }
        }
    }

    /**
     * Ëé∑ÂèñÂΩìÂâçÁä∂ÊÄÅ
     */
    getCurrentState() {
        return { ...this.currentState };
    }

    /**
     * ÂÅúÊ≠¢ÁõëÊéß
     */
    stopMonitoring() {
        if (this.domCheckInterval) {
            clearInterval(this.domCheckInterval);
        }
        this.monitoringActive = false;
        console.log('üõë È°µÈù¢Áä∂ÊÄÅÁõëÊéßÂô®Â∑≤ÂÅúÊ≠¢');
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * üóÇÔ∏è Êô∫ËÉΩÊ†áÁ≠æÈ°µÁÆ°ÁêÜÂô® - ÂÖ®Èù¢ÈáçÊûÑÁâà
 */
class SmartTabManager {
    constructor(browser, context) {
        this.browser = browser;
        this.context = context;
        this.tabs = new Map();
        this.activeTab = null;
        this.lastUpdateTime = 0;
        this.updateInterval = null;
    }

    /**
     * ÂêØÂä®Ê†áÁ≠æÈ°µÁõëÊéß
     */
    async startMonitoring() {
        console.log('üóÇÔ∏è ÂêØÂä®Êô∫ËÉΩÊ†áÁ≠æÈ°µÁÆ°ÁêÜÂô®...');
        
        // ÁõëÂê¨Êñ∞È°µÈù¢ÂàõÂª∫
        this.context.on('page', (page) => {
            console.log('üìÑ Ê£ÄÊµãÂà∞Êñ∞È°µÈù¢ÂàõÂª∫');
            this.handleNewPage(page);
        });

        // ÂÆöÊúüÊõ¥Êñ∞Ê†áÁ≠æÈ°µ‰ø°ÊÅØ
        this.updateInterval = setInterval(() => {
            this.updateAllTabs().catch(console.error);
        }, 3000);

        // ÂàùÂßãÊâ´Êèè
        await this.updateAllTabs();
        
        console.log('‚úÖ Êô∫ËÉΩÊ†áÁ≠æÈ°µÁÆ°ÁêÜÂô®Â∑≤ÂêØÂä®');
    }

    /**
     * Â§ÑÁêÜÊñ∞È°µÈù¢
     */
    async handleNewPage(page) {
        try {
            // Á≠âÂæÖÈ°µÈù¢Âü∫Êú¨Âä†ËΩΩ
            await page.waitForLoadState('domcontentloaded', { timeout: 5000 });
            
            const tabInfo = await this.createTabInfo(page);
            this.tabs.set(page, tabInfo);
            
            console.log(`üìÑ Êñ∞Ê†áÁ≠æÈ°µÂ∑≤Ê≥®ÂÜå: ${tabInfo.title}`);
            
            // Êô∫ËÉΩÂàáÊç¢ÈÄªËæë
            await this.smartSwitchTab();
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Â§ÑÁêÜÊñ∞È°µÈù¢Â§±Ë¥•:', error.message);
        }
    }

    /**
     * Êõ¥Êñ∞ÊâÄÊúâÊ†áÁ≠æÈ°µ‰ø°ÊÅØ
     */
    async updateAllTabs() {
        try {
            const currentPages = this.context.pages();
            
            // Ê∏ÖÁêÜÂ∑≤ÂÖ≥Èó≠ÁöÑÈ°µÈù¢
            for (const [page] of this.tabs) {
                if (!currentPages.includes(page)) {
                    console.log('üóëÔ∏è Ê∏ÖÁêÜÂ∑≤ÂÖ≥Èó≠ÁöÑÊ†áÁ≠æÈ°µ');
                    this.tabs.delete(page);
                }
            }

            // Êõ¥Êñ∞Áé∞ÊúâÈ°µÈù¢‰ø°ÊÅØ
            for (const page of currentPages) {
                try {
                    const tabInfo = await this.createTabInfo(page);
                    this.tabs.set(page, tabInfo);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Êõ¥Êñ∞Ê†áÁ≠æÈ°µ‰ø°ÊÅØÂ§±Ë¥•:', error.message);
                }
            }

            // Êô∫ËÉΩÈÄâÊã©Ê¥ªÂä®Ê†áÁ≠æÈ°µ
            await this.smartSwitchTab();
            
            this.lastUpdateTime = Date.now();

        } catch (error) {
            console.error('‚ùå Êõ¥Êñ∞Ê†áÁ≠æÈ°µÂ§±Ë¥•:', error.message);
        }
    }

    /**
     * ÂàõÂª∫Ê†áÁ≠æÈ°µ‰ø°ÊÅØ
     */
    async createTabInfo(page) {
        try {
            const url = await page.url();
            const title = await page.title();
            
            const pageInfo = await page.evaluate(() => {
                return {
                    readyState: document.readyState,
                    elementCount: document.querySelectorAll('*').length,
                    interactiveCount: document.querySelectorAll(
                        'button, input, a, select, textarea, [onclick], [role="button"]'
                    ).length,
                    hasContent: document.body ? document.body.innerText.trim().length > 100 : false,
                    timestamp: Date.now()
                };
            }).catch(() => ({
                readyState: 'loading',
                elementCount: 0,
                interactiveCount: 0,
                hasContent: false,
                timestamp: Date.now()
            }));

            return {
                page: page,
                url: url,
                title: title,
                ...pageInfo,
                lastUpdate: Date.now(),
                score: this.calculateTabScore(url, title, pageInfo)
            };

        } catch (error) {
            console.warn('‚ö†Ô∏è ÂàõÂª∫Ê†áÁ≠æÈ°µ‰ø°ÊÅØÂ§±Ë¥•:', error.message);
            return {
                page: page,
                url: 'unknown',
                title: 'Unknown',
                readyState: 'loading',
                elementCount: 0,
                interactiveCount: 0,
                hasContent: false,
                lastUpdate: Date.now(),
                score: 0
            };
        }
    }

    /**
     * ËÆ°ÁÆóÊ†áÁ≠æÈ°µËØÑÂàÜ
     */
    calculateTabScore(url, title, pageInfo) {
        let score = 0;
        
        // È°µÈù¢Âä†ËΩΩÁä∂ÊÄÅÂæóÂàÜ
        if (pageInfo.readyState === 'complete') score += 30;
        else if (pageInfo.readyState === 'interactive') score += 15;
        
        // ÂÜÖÂÆπ‰∏∞ÂØåÂ∫¶ÂæóÂàÜ
        if (pageInfo.hasContent) score += 20;
        score += Math.min(pageInfo.interactiveCount * 2, 30);
        score += Math.min(pageInfo.elementCount / 50, 20);
        
        // URL‰ºòÂÖàÁ∫ßÂæóÂàÜÔºàÁîµÂïÜ„ÄÅÊêúÁ¥¢ÁªìÊûúÁ≠âÔºâ
        const priorityDomains = [
            'taobao.com', 'tmall.com', 'jd.com', 'amazon',
            'search', 'results', 'item', 'product', 'detail'
        ];
        
        for (const domain of priorityDomains) {
            if (url.toLowerCase().includes(domain)) {
                score += 25;
                break;
            }
        }

        // ÊúÄËøëÊõ¥Êñ∞ÂæóÂàÜ
        const timeSinceUpdate = Date.now() - pageInfo.timestamp;
        score += Math.max(0, 20 - (timeSinceUpdate / 1000));

        return Math.round(score);
    }

    /**
     * Êô∫ËÉΩÂàáÊç¢Ê†áÁ≠æÈ°µ
     */
    async smartSwitchTab() {
        try {
            if (this.tabs.size === 0) return null;

            let bestTab = null;
            let bestScore = -1;

            for (const tabInfo of this.tabs.values()) {
                if (tabInfo.score > bestScore) {
                    bestScore = tabInfo.score;
                    bestTab = tabInfo;
                }
            }

            if (bestTab && bestTab.page !== this.activeTab) {
                console.log(`üîÑ Êô∫ËÉΩÂàáÊç¢Âà∞ÊúÄ‰Ω≥Ê†áÁ≠æÈ°µ: ${bestTab.title} (ËØÑÂàÜ: ${bestScore})`);
                
                this.activeTab = bestTab.page;
                
                // Á°Æ‰øùÈ°µÈù¢ÂèØËßÅ
                await this.activeTab.bringToFront();
                await this.sleep(500);
                
                return this.activeTab;
            }

            return this.activeTab;

        } catch (error) {
            console.error('‚ùå Êô∫ËÉΩÂàáÊç¢Ê†áÁ≠æÈ°µÂ§±Ë¥•:', error.message);
            return this.activeTab;
        }
    }

    /**
     * Ëé∑ÂèñÊ¥ªÂä®Ê†áÁ≠æÈ°µ
     */
    getActiveTab() {
        return this.activeTab;
    }

    /**
     * Ëé∑ÂèñÊâÄÊúâÊ†áÁ≠æÈ°µ‰ø°ÊÅØ
     */
    getAllTabsInfo() {
        return Array.from(this.tabs.values());
    }

    /**
     * ÂÅúÊ≠¢ÁõëÊéß
     */
    stopMonitoring() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        console.log('üõë Ê†áÁ≠æÈ°µÁÆ°ÁêÜÂô®Â∑≤ÂÅúÊ≠¢');
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * DOMÂÖÉÁ¥†Ê£ÄÊµãÂô®
 */
class AdvancedDOMDetector {
    constructor(page, pageStateMonitor) {
        this.page = page;
        this.pageStateMonitor = pageStateMonitor;
        this.lastDetection = null;
        this.detectionCache = new Map();
        this.markersActive = false;
        this.detectionId = 0;
    }

    /**
     * Êô∫ËÉΩÊ£ÄÊµãÈ°µÈù¢ÂÖÉÁ¥† - Ê†∏ÂøÉÊñπÊ≥ï
     */
    async detectElements(forceRefresh = false) {
        try {
            const detectionStartTime = Date.now();
            const currentState = this.pageStateMonitor.getCurrentState();
            
            console.log('üîç ÂêØÂä®È´òÁ∫ßDOMÂÖÉÁ¥†Ê£ÄÊµã...');
            
            // Êô∫ËÉΩÁºìÂ≠òÊ£ÄÊü•
            if (!forceRefresh && this.shouldUseCache(currentState)) {
                console.log('üìã ‰ΩøÁî®ÁºìÂ≠òÁöÑÊ£ÄÊµãÁªìÊûú');
                return this.lastDetection;
            }

            console.log('üîÑ ÊâßË°åÊñ∞ÁöÑÂÖÉÁ¥†Ê£ÄÊµã...');
            
            // Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆö
            await this.waitForStable();
            
            // Ê∏ÖÈô§ÊóßÊ†áËÆ∞
            await this.clearMarkers();
            
            // ÊâßË°åÊ£ÄÊµã
            const elements = await this.performDetection();
            
            // ÂàõÂª∫Ê£ÄÊµãÁªìÊûú
            const detection = {
                id: ++this.detectionId,
                timestamp: Date.now(),
                pageState: { ...currentState },
                elements: elements,
                totalElements: elements.length,
                detectionTime: Date.now() - detectionStartTime,
                hasMarkers: this.markersActive
            };

            // Êõ¥Êñ∞ÁºìÂ≠ò
            this.lastDetection = detection;
            this.updateCache(currentState, detection);
            
            console.log(`‚úÖ DOMÊ£ÄÊµãÂÆåÊàê: ${elements.length}‰∏™ÂÖÉÁ¥† (ËÄóÊó∂: ${detection.detectionTime}ms)`);
            
            return detection;

        } catch (error) {
            console.error('‚ùå DOMÂÖÉÁ¥†Ê£ÄÊµãÂ§±Ë¥•:', error.message);
            return {
                id: ++this.detectionId,
                timestamp: Date.now(),
                elements: [],
                totalElements: 0,
                error: error.message,
                hasMarkers: false
            };
        }
    }

    /**
     * Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•‰ΩøÁî®ÁºìÂ≠ò
     */
    shouldUseCache(currentState) {
        if (!this.lastDetection) return false;
        
        const timeDiff = Date.now() - this.lastDetection.timestamp;
        if (timeDiff > 10000) return false; // 10ÁßíÂêéÂº∫Âà∂Âà∑Êñ∞
        
        const lastState = this.lastDetection.pageState;
        
        // Ê£ÄÊü•ÂÖ≥ÈîÆÁä∂ÊÄÅÂèòÂåñ
        return (
            currentState.url === lastState.url &&
            currentState.domHash === lastState.domHash &&
            !currentState.hasNewContent
        );
    }

    /**
     * Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆö
     */
    async waitForStable() {
        try {
            console.log('‚è≥ Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆöÁî®‰∫éÊ£ÄÊµã...');
            
            // Á≠âÂæÖÂü∫Êú¨Âä†ËΩΩ
            await this.page.waitForLoadState('domcontentloaded', { timeout: 8000 });
            
            // Ê£ÄÊü•Âä®ÊÄÅÂÜÖÂÆπÁ®≥ÂÆöÊÄß
            let stableCount = 0;
            const maxChecks = 5;
            
            for (let i = 0; i < maxChecks; i++) {
                const elementCount = await this.page.evaluate(() => 
                    document.querySelectorAll('*').length
                );
                
                await this.sleep(500);
                
                const newElementCount = await this.page.evaluate(() => 
                    document.querySelectorAll('*').length
                );
                
                if (Math.abs(newElementCount - elementCount) < 5) {
                    stableCount++;
                    if (stableCount >= 2) {
                        console.log('‚úÖ È°µÈù¢DOMÁªìÊûÑÂ∑≤Á®≥ÂÆö');
                        break;
                    }
                } else {
                    stableCount = 0;
                }
            }
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Á≠âÂæÖÈ°µÈù¢Á®≥ÂÆöË∂ÖÊó∂:', error.message);
        }
    }

    /**
     * ÊâßË°åÂÖÉÁ¥†Ê£ÄÊµã - Ê†∏ÂøÉÁÆóÊ≥ï
     */
    async performDetection() {
        console.log('üéØ Ê≥®ÂÖ•ÂÖÉÁ¥†Ê£ÄÊµãËÑöÊú¨...');
        
        const elements = await this.page.evaluate((ElementTypes) => {
            // Ê∏ÖÈô§‰πãÂâçÁöÑÊ†áËÆ∞
            document.querySelectorAll('.ai-element-marker').forEach(el => el.remove());
            
            const results = [];
            let elementCounter = 0;
            
            // ÂàõÂª∫ÂÖÉÁ¥†Ê£ÄÊµãÂô®
            class ElementDetector {
                constructor() {
                    this.viewport = {
                        width: window.innerWidth,
                        height: window.innerHeight,
                        scrollX: window.scrollX,
                        scrollY: window.scrollY
                    };
                }

                // Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶ÂèØ‰∫§‰∫í
                isInteractive(element) {
                    // Âü∫Êú¨‰∫§‰∫íÊÄßÊ£ÄÊü•
                    if (element.disabled || element.hidden) return false;
                    
                    // Ê†∑ÂºèÊ£ÄÊü•
                    const style = window.getComputedStyle(element);
                    if (style.display === 'none' || style.visibility === 'hidden') return false;
                    if (style.pointerEvents === 'none') return false;
                    if (parseFloat(style.opacity) < 0.1) return false;
                    
                    // Â∞∫ÂØ∏Ê£ÄÊü•
                    const rect = element.getBoundingClientRect();
                    if (rect.width < 3 || rect.height < 3) return false;
                    
                    return true;
                }

                // Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶ÂèØËßÅ
                isVisible(element) {
                    const rect = element.getBoundingClientRect();
                    const viewport = this.viewport;
                    
                    // Êâ©Â±ïËßÜÂè£Ê£ÄÊü•ÔºàÂåÖÂê´ÊªöÂä®Âå∫ÂüüÔºâ
                    return (
                        rect.top < viewport.height + 1000 &&
                        rect.bottom > -1000 &&
                        rect.left < viewport.width + 500 &&
                        rect.right > -500
                    );
                }

                // ÂàÜÁ±ªÂÖÉÁ¥†Á±ªÂûã
                classifyElement(element) {
                    for (const [typeName, typeConfig] of Object.entries(ElementTypes)) {
                        if (element.matches(typeConfig.selector)) {
                            return typeConfig;
                        }
                    }
                    return ElementTypes.INTERACTIVE;
                }

                // Ëé∑ÂèñÂÖÉÁ¥†ÊñáÊú¨ÂÜÖÂÆπ
                getElementText(element) {
                    const textSources = [
                        () => element.value && element.value.trim(),
                        () => element.textContent && element.textContent.trim(),
                        () => element.innerText && element.innerText.trim(),
                        () => element.alt && element.alt.trim(),
                        () => element.title && element.title.trim(),
                        () => element.placeholder && element.placeholder.trim(),
                        () => element.getAttribute('aria-label') && element.getAttribute('aria-label').trim(),
                        () => element.name && element.name.trim(),
                        () => element.id && element.id.trim()
                    ];
                    
                    for (const getTextFn of textSources) {
                        const text = getTextFn();
                        if (text) {
                            return text.replace(/\s+/g, ' ').substring(0, 200);
                        }
                    }
                    
                    return '';
                }

                // ÂàõÂª∫ËßÜËßâÊ†áËÆ∞
                createMarker(element, number, elementType) {
                    try {
                        const rect = element.getBoundingClientRect();
                        if (rect.width < 3 || rect.height < 3) return null;
                        
                        const marker = document.createElement('div');
                        marker.className = 'ai-element-marker';
                        marker.style.cssText = `
                            position: fixed;
                            top: ${rect.top}px;
                            left: ${rect.left}px;
                            width: ${rect.width}px;
                            height: ${rect.height}px;
                            pointer-events: none;
                            z-index: 999999;
                            border: 3px solid ${elementType.color};
                            border-radius: 4px;
                            background: ${elementType.bgColor};
                            box-shadow: 0 0 10px ${elementType.color}40;
                            transition: all 0.2s ease;
                        `;
                        
                        // ÂàõÂª∫Êï∞Â≠óÊ†áÁ≠æ
                        const label = document.createElement('div');
                        label.style.cssText = `
                            position: absolute;
                            top: -18px;
                            left: -3px;
                            background: ${elementType.color};
                            color: white;
                            font-size: 12px;
                            font-weight: bold;
                            padding: 4px 8px;
                            border-radius: 4px;
                            font-family: monospace;
                            line-height: 1;
                            min-width: 20px;
                            text-align: center;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            border: 2px solid white;
                        `;
                        label.textContent = number.toString();
                        
                        marker.appendChild(label);
                        document.body.appendChild(marker);
                        
                        return marker;
                    } catch (error) {
                        console.warn('ÂàõÂª∫Ê†áËÆ∞Â§±Ë¥•:', error);
                        return null;
                    }
                }

                // ËÆ°ÁÆóÂÖÉÁ¥†ÁΩÆ‰ø°Â∫¶
                calculateConfidence(element, isVisible, text, elementType) {
                    let confidence = 50;
                    
                    // ÂèØËßÅÊÄßÂä†ÂàÜ
                    if (isVisible) confidence += 25;
                    
                    // ÊñáÊú¨ÂÜÖÂÆπÂä†ÂàÜ
                    if (text && text.length > 0) confidence += 15;
                    if (text && text.length > 10) confidence += 10;
                    
                    // ÂÖÉÁ¥†Á±ªÂûãÂä†ÂàÜ
                    confidence += elementType.priority / 10;
                    
                    // Â±ûÊÄßÂÆåÊï¥ÊÄßÂä†ÂàÜ
                    if (element.id) confidence += 10;
                    if (element.name) confidence += 8;
                    if (element.className) confidence += 5;
                    
                    // ÂèØÁî®ÊÄßÂä†ÂàÜ
                    if (!element.disabled) confidence += 10;
                    
                    // ‰∫§‰∫íÊÄßÂä†ÂàÜ
                    if (element.onclick || element.addEventListener) confidence += 15;
                    
                    return Math.min(confidence, 100);
                }

                // Ê£ÄÊµãÊâÄÊúâ‰∫§‰∫íÂÖÉÁ¥†
                detectAll() {
                    console.log('üîç ÂºÄÂßãÊ£ÄÊµã‰∫§‰∫íÂÖÉÁ¥†...');
                    
                    // Ëé∑ÂèñÊâÄÊúâÊΩúÂú®‰∫§‰∫íÂÖÉÁ¥†
                    const allSelectors = Object.values(ElementTypes)
                        .map(type => type.selector)
                        .join(', ');
                    
                    const candidates = document.querySelectorAll(allSelectors);
                    console.log(`üìä ÊâæÂà∞ ${candidates.length} ‰∏™ÂÄôÈÄâÂÖÉÁ¥†`);
                    
                    const validElements = [];
                    
                    candidates.forEach(element => {
                        try {
                            // Âü∫Êú¨Ê£ÄÊü•
                            if (!this.isInteractive(element)) return;
                            
                            const elementType = this.classifyElement(element);
                            const isVisible = this.isVisible(element);
                            const text = this.getElementText(element);
                            
                            // Âè™Â§ÑÁêÜÂèØËßÅÊàñÊé•ËøëÂèØËßÅÁöÑÂÖÉÁ¥†
                            if (!isVisible && !this.isNearVisible(element)) return;
                            
                            const elementNumber = ++elementCounter;
                            const rect = element.getBoundingClientRect();
                            
                            // ÂàõÂª∫Ê†áËÆ∞Ôºà‰ªÖ‰∏∫ÂèØËßÅÂÖÉÁ¥†Ôºâ
                            let marker = null;
                            if (isVisible && rect.width > 5 && rect.height > 5) {
                                marker = this.createMarker(element, elementNumber, elementType);
                            }
                            
                            // ‰∏∫ÂÖÉÁ¥†Ê∑ªÂä†Ê†áËØÜ
                            element.setAttribute('data-ai-element-id', elementNumber);
                            element.setAttribute('data-ai-element-type', elementType.name);
                            
                            const confidence = this.calculateConfidence(element, isVisible, text, elementType);
                            
                            const elementInfo = {
                                number: elementNumber,
                                tagName: element.tagName.toLowerCase(),
                                type: element.type || '',
                                text: text,
                                description: this.createDescription(element, elementType, text),
                                elementType: elementType.name,
                                elementTypeConfig: elementType,
                                
                                attributes: {
                                    id: element.id || '',
                                    className: element.className || '',
                                    name: element.name || '',
                                    placeholder: element.placeholder || '',
                                    value: element.value || '',
                                    href: element.href || '',
                                    role: element.getAttribute('role') || '',
                                    'aria-label': element.getAttribute('aria-label') || ''
                                },
                                
                                position: {
                                    x: Math.round(rect.left + this.viewport.scrollX),
                                    y: Math.round(rect.top + this.viewport.scrollY),
                                    width: Math.round(rect.width),
                                    height: Math.round(rect.height),
                                    centerX: Math.round(rect.left + rect.width / 2 + this.viewport.scrollX),
                                    centerY: Math.round(rect.top + rect.height / 2 + this.viewport.scrollY),
                                    viewportX: Math.round(rect.left),
                                    viewportY: Math.round(rect.top)
                                },
                                
                                state: {
                                    isVisible: isVisible,
                                    isClickable: isVisible && !element.disabled,
                                    isEditable: this.isEditable(element),
                                    isEnabled: !element.disabled,
                                    isFocusable: this.isFocusable(element),
                                    hasMarker: marker !== null
                                },
                                
                                confidence: confidence,
                                interactionType: elementType.interactionType,
                                timestamp: Date.now()
                            };
                            
                            validElements.push(elementInfo);
                            
                        } catch (error) {
                            console.warn('ÂÖÉÁ¥†ÂàÜÊûêÂ§±Ë¥•:', error);
                        }
                    });
                    
                    // Êåâ‰ºòÂÖàÁ∫ßÂíåÁΩÆ‰ø°Â∫¶ÊéíÂ∫è
                    validElements.sort((a, b) => {
                        // È¶ñÂÖàÊåâÂÖÉÁ¥†Á±ªÂûã‰ºòÂÖàÁ∫ß
                        const priorityDiff = b.elementTypeConfig.priority - a.elementTypeConfig.priority;
                        if (priorityDiff !== 0) return priorityDiff;
                        
                        // ÁÑ∂ÂêéÊåâÁΩÆ‰ø°Â∫¶
                        const confidenceDiff = b.confidence - a.confidence;
                        if (confidenceDiff !== 0) return confidenceDiff;
                        
                        // ÊúÄÂêéÊåâÂèØËßÅÊÄß
                        return b.state.isVisible - a.state.isVisible;
                    });
                    
                    console.log(`‚úÖ Ê£ÄÊµãÂÆåÊàê: ${validElements.length} ‰∏™ÊúâÊïà‰∫§‰∫íÂÖÉÁ¥†`);
                    
                    return validElements;
                }

                // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÂèØËßÅ
                isNearVisible(element) {
                    const rect = element.getBoundingClientRect();
                    const viewport = this.viewport;
                    
                    return (
                        rect.top < viewport.height + 500 &&
                        rect.bottom > -500 &&
                        rect.left < viewport.width + 300 &&
                        rect.right > -300
                    );
                }

                // Ê£ÄÊü•ÊòØÂê¶ÂèØÁºñËæë
                isEditable(element) {
                    const tagName = element.tagName.toLowerCase();
                    if (tagName === 'input' && !['button', 'submit', 'reset', 'checkbox', 'radio'].includes(element.type)) {
                        return !element.readOnly && !element.disabled;
                    }
                    if (tagName === 'textarea') {
                        return !element.readOnly && !element.disabled;
                    }
                    return element.contentEditable === 'true';
                }

                // Ê£ÄÊü•ÊòØÂê¶ÂèØËÅöÁÑ¶
                isFocusable(element) {
                    if (element.tabIndex >= 0) return true;
                    const tagName = element.tagName.toLowerCase();
                    return ['input', 'textarea', 'select', 'button', 'a'].includes(tagName);
                }

                // ÂàõÂª∫ÂÖÉÁ¥†ÊèèËø∞
                createDescription(element, elementType, text) {
                    let description = elementType.description;
                    
                    if (text) {
                        description += `: ${text}`;
                    } else if (element.placeholder) {
                        description += `: ${element.placeholder}`;
                    } else if (element.id) {
                        description += `: #${element.id}`;
                    } else if (element.className) {
                        const mainClass = element.className.split(' ')[0];
                        description += `: .${mainClass}`;
                    } else {
                        description += `: ${element.tagName.toLowerCase()}`;
                    }
                    
                    return description;
                }
            }
            
            // ÊâßË°åÊ£ÄÊµã
            const detector = new ElementDetector();
            return detector.detectAll();
            
        }, ElementTypes);

        this.markersActive = elements.length > 0;
        console.log(`üé® Â∑≤ÂàõÂª∫ ${elements.length} ‰∏™ÂÖÉÁ¥†Ê†áËÆ∞`);
        
        return elements;
    }

    /**
     * Ê∏ÖÈô§ËßÜËßâÊ†áËÆ∞
     */
    async clearMarkers() {
        try {
            await this.page.evaluate(() => {
                document.querySelectorAll('.ai-element-marker').forEach(el => el.remove());
            });
            this.markersActive = false;
            console.log('üßπ Â∑≤Ê∏ÖÈô§ÊâÄÊúâËßÜËßâÊ†áËÆ∞');
        } catch (error) {
            console.warn('‚ö†Ô∏è Ê∏ÖÈô§Ê†áËÆ∞Â§±Ë¥•:', error.message);
        }
    }

    /**
     * Ê†πÊçÆÁºñÂè∑Ëé∑ÂèñÂÖÉÁ¥†
     */
    getElementById(elementNumber) {
        if (!this.lastDetection) return null;
        return this.lastDetection.elements.find(el => el.number === elementNumber) || null;
    }

    /**
     * Ëé∑ÂèñÂÖÉÁ¥†ÂàóË°®‰æõAI‰ΩøÁî®
     */
    getElementsForAI(maxElements = 20) {
        if (!this.lastDetection) return [];
        
        return this.lastDetection.elements
            .slice(0, maxElements)
            .map(element => ({
                number: element.number,
                elementType: element.elementType,
                description: element.description,
                text: element.text.substring(0, 100),
                interactionType: element.interactionType,
                confidence: element.confidence,
                position: `(${element.position.centerX}, ${element.position.centerY})`,
                state: element.state.isClickable ? 'clickable' : 
                       element.state.isEditable ? 'editable' : 'visible',
                isVisible: element.state.isVisible,
                isEnabled: element.state.isEnabled,
                hasMarker: element.state.hasMarker
            }));
    }

    /**
     * Êõ¥Êñ∞ÁºìÂ≠ò
     */
    updateCache(pageState, detection) {
        const cacheKey = `${pageState.url}_${pageState.domHash}`;
        this.detectionCache.set(cacheKey, {
            detection: detection,
            timestamp: Date.now()
        });
        
        // Ê∏ÖÁêÜËøáÊúüÁºìÂ≠ò
        const expireTime = Date.now() - 30000; // 30ÁßíËøáÊúü
        for (const [key, value] of this.detectionCache.entries()) {
            if (value.timestamp < expireTime) {
                this.detectionCache.delete(key);
            }
        }
    }

    /**
     * Ëé∑ÂèñÊ£ÄÊµã‰ø°ÊÅØ
     */
    getDetectionInfo() {
        return this.lastDetection ? {
            id: this.lastDetection.id,
            timestamp: this.lastDetection.timestamp,
            totalElements: this.lastDetection.totalElements,
            detectionTime: this.lastDetection.detectionTime,
            hasMarkers: this.lastDetection.hasMarkers
        } : null;
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * üß† Â¢ûÂº∫AIÂÜ≥Á≠ñÂºïÊìé - Âü∫‰∫éÂ§öÊ®°ÊÄÅËÉΩÂäõÈáçÊûÑ
 */
class EnhancedAIDecisionEngine {
    constructor(page, pageStateMonitor) {
        this.page = page;
        this.pageStateMonitor = pageStateMonitor;
        this.apiEndpoint = 'https://yuanplus.cloud/v1/chat/completions';
        this.apiKey = 'sk-t8zcWN8dFJxaD18REKRrdLzlngOJlmpkzvfomfyLwaYMNcO6';
        this.decisionTimeout = 60000;
        this.decisionHistory = [];
        this.maxHistorySize = 10;
    }

    /**
     * ÂÅöÂá∫Êô∫ËÉΩÂÜ≥Á≠ñ
     */
    async makeDecision(task, elementList, pageState, stepCount, operationHistory = []) {
        const decisionStartTime = Date.now();
        
        try {
            console.log('üß† ÂêØÂä®Â¢ûÂº∫AIÂÜ≥Á≠ñÂàÜÊûê...');
            
            // ÊçïËé∑È°µÈù¢Êà™Âõæ
            const screenshot = await this.captureScreenshot();
            
            // ÊûÑÂª∫ÂÜ≥Á≠ñ‰∏ä‰∏ãÊñá
            const messages = this.buildDecisionMessages(
                task, elementList, pageState, stepCount, 
                operationHistory, screenshot
            );
            
            // Ë∞ÉÁî®AI API
            const decision = await this.callAI(messages);
            
            if (decision) {
                const decisionTime = Date.now() - decisionStartTime;
                console.log(`‚úÖ AIÂÜ≥Á≠ñÊàêÂäü (ËÄóÊó∂: ${decisionTime}ms)`);
                console.log(`üîß ÈÄâÊã©Â∑•ÂÖ∑: ${decision.tool}`);
                console.log(`üí≠ ÂÜ≥Á≠ñÁêÜÁî±: ${decision.reasoning.substring(0, 100)}...`);
                
                // ËÆ∞ÂΩïÂÜ≥Á≠ñÂéÜÂè≤
                this.recordDecision(decision, decisionTime);
                
                return decision;
            }
            
            console.error('‚ùå AIÂÜ≥Á≠ñÂ§±Ë¥•ÔºöÊó†ÊúâÊïàÂìçÂ∫î');
            return null;
            
        } catch (error) {
            console.error('‚ùå AIÂÜ≥Á≠ñÂºÇÂ∏∏:', error.message);
            return null;
        }
    }

    /**
     * ÊçïËé∑È°µÈù¢Êà™Âõæ
     */
    async captureScreenshot() {
        try {
            const screenshot = await this.page.screenshot({
                type: 'jpeg',
                quality: 80,
                fullPage: false,
                animations: 'disabled',
                clip: {
                    x: 0,
                    y: 0,
                    width: Math.min(1920, await this.page.evaluate(() => window.innerWidth)),
                    height: Math.min(1080, await this.page.evaluate(() => window.innerHeight))
                }
            });
            
            return screenshot.toString('base64');
        } catch (error) {
            console.warn('‚ö†Ô∏è Êà™ÂõæÂ§±Ë¥•:', error.message);
            return null;
        }
    }

    /**
     * ÊûÑÂª∫ÂÜ≥Á≠ñÊ∂àÊÅØ
     */
    buildDecisionMessages(task, elementList, pageState, stepCount, operationHistory, screenshot) {
        const messages = [];
        
        // Á≥ªÁªüÊèêÁ§∫
        messages.push({
            role: 'system',
            content: this.buildSystemPrompt()
        });

        // Êìç‰ΩúÂéÜÂè≤‰∏ä‰∏ãÊñá
        if (operationHistory.length > 0) {
            messages.push({
                role: 'assistant',
                content: this.buildHistoryContext(operationHistory)
            });
        }

        // ÂΩìÂâç‰ªªÂä°Ê∂àÊÅØ
        const userMessage = {
            role: 'user',
            content: this.buildTaskPrompt(task, elementList, pageState, stepCount)
        };

        // Ê∑ªÂä†Êà™Âõæ
        if (screenshot) {
            userMessage.content = [
                { type: 'text', text: userMessage.content },
                {
                    type: 'image_url',
                    image_url: {
                        url: `data:image/jpeg;base64,${screenshot}`,
                        detail: 'high'
                    }
                }
            ];
        }

        messages.push(userMessage);
        
        return messages;
    }

    /**
     * ÊûÑÂª∫Á≥ªÁªüÊèêÁ§∫
     */
    buildSystemPrompt() {
        return `‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÁΩëÈ°µËá™Âä®ÂåñAIÂä©ÊâãÔºåÂÖ∑Â§á‰ª•‰∏ãÊ†∏ÂøÉËÉΩÂäõÔºö

üéØ Ê†∏ÂøÉ‰ªªÂä°ËÉΩÂäõÔºö
- Êô∫ËÉΩÂàÜÊûêÁΩëÈ°µÂÜÖÂÆπÂíåÁªìÊûÑ
- ÂáÜÁ°ÆËØÜÂà´ÂíåÊìç‰ΩúÈ°µÈù¢ÂÖÉÁ¥†
- Â§ÑÁêÜÂ§çÊùÇÁöÑÂ§öÊ≠•È™§‰ªªÂä°ÊµÅÁ®ã
- ÈÄÇÂ∫î‰∏çÂêåÁΩëÁ´ôÁöÑÁïåÈù¢ÂèòÂåñ

üé® ÂÖÉÁ¥†ËØÜÂà´Á≥ªÁªüÔºö
- üî¥ Á∫¢Ëâ≤Ê†áËÆ∞ = ÊåâÈíÆÁ±ªÂÖÉÁ¥† (button) - Áî®‰∫éÁÇπÂáªÊìç‰Ωú
- üü† Ê©ôËâ≤Ê†áËÆ∞ = ËæìÂÖ•Ê°ÜÂÖÉÁ¥† (input) - Áî®‰∫éÊñáÊú¨ËæìÂÖ•
- üü¢ ÁªøËâ≤Ê†áËÆ∞ = ÈìæÊé•ÂÖÉÁ¥† (link) - Áî®‰∫éÈ°µÈù¢Ë∑≥ËΩ¨
- üîµ ËìùËâ≤Ê†áËÆ∞ = ÈÄâÊã©Êéß‰ª∂ (select) - Áî®‰∫éÈÄâÊã©Êìç‰Ωú
- üü£ Á¥´Ëâ≤Ê†áËÆ∞ = ‰∫§‰∫íÂÖÉÁ¥† (interactive) - Áî®‰∫éÂ§çÊùÇ‰∫§‰∫í
- üü° ÈªÑËâ≤Ê†áËÆ∞ = Ëá™ÂÆö‰πâÂÖÉÁ¥† (custom) - Áî®‰∫éÁâπÊÆäÂäüËÉΩ

üß† Êô∫ËÉΩÂÜ≥Á≠ñÂéüÂàôÔºö
1. ‰ºòÂÖàÂàÜÊûêÈ°µÈù¢Êà™ÂõæÔºåÁêÜËß£ÂΩìÂâçÁä∂ÊÄÅ
2. Ê†πÊçÆ‰ªªÂä°ÁõÆÊ†áÈÄâÊã©ÊúÄÂêàÈÄÇÁöÑÊìç‰Ωú
3. ËÄÉËôëÊìç‰ΩúÂéÜÂè≤ÔºåÈÅøÂÖçÈáçÂ§çÊó†ÊïàÊìç‰Ωú
4. Ê£ÄÊµãÈ°µÈù¢Ë∑≥ËΩ¨ÔºåÈÄÇÂ∫îÊñ∞ÁöÑÈ°µÈù¢Áä∂ÊÄÅ
5. ÈÄâÊã©ÁΩÆ‰ø°Â∫¶È´ò„ÄÅÁä∂ÊÄÅËâØÂ•ΩÁöÑÂÖÉÁ¥†
6. Âú®‰ªªÂä°ÂÆåÊàêÊó∂ÂèäÊó∂ÂÅúÊ≠¢

üö® ÈáçË¶ÅÊìç‰ΩúÊåáÂØºÔºö
- È°µÈù¢Ë∑≥ËΩ¨ÂêéË¶ÅÈáçÊñ∞ÂàÜÊûêÊñ∞È°µÈù¢ÁöÑÂÜÖÂÆπ
- ÊêúÁ¥¢Êìç‰ΩúÊàêÂäüÂêéÈÄöÂ∏∏‰ºöË∑≥ËΩ¨Âà∞ÁªìÊûúÈ°µÈù¢
- Âú®ÁªìÊûúÈ°µÈù¢Â∫îËØ•ÊµèËßàÂïÜÂìÅËÄå‰∏çÊòØÈáçÂ§çÊêúÁ¥¢
- Ê†πÊçÆÈ°µÈù¢ÂÜÖÂÆπÂà§Êñ≠‰ªªÂä°ÊòØÂê¶Â∑≤ÁªèÂÆåÊàê
- ÈÅøÂÖçÂú®Âêå‰∏ÄÈ°µÈù¢ÈáçÂ§çÊâßË°åÁõ∏ÂêåÊìç‰Ωú

ËØ∑Âü∫‰∫éÈ°µÈù¢Êà™ÂõæÂíåÂÖÉÁ¥†‰ø°ÊÅØÔºåÈÄâÊã©ÊúÄ‰Ω≥ÁöÑ‰∏ã‰∏ÄÊ≠•Êìç‰Ωú„ÄÇ`;
    }

    /**
     * ÊûÑÂª∫ÂéÜÂè≤‰∏ä‰∏ãÊñá
     */
    buildHistoryContext(operationHistory) {
        let context = 'üìä ÊúÄËøëÊìç‰ΩúÂéÜÂè≤Ôºö\n\n';
        
        operationHistory.slice(-5).forEach((op, index) => {
            context += `Ê≠•È™§${op.step}: ${op.tool}`;
            if (op.params.element_number) {
                context += ` (ÂÖÉÁ¥†#${op.params.element_number})`;
            }
            context += ` - ${op.result.success ? 'ÊàêÂäü' : 'Â§±Ë¥•'}\n`;
            
            if (op.params.text_content) {
                context += `  ËæìÂÖ•ÂÜÖÂÆπ: "${op.params.text_content}"\n`;
            }
            if (op.params.element_description) {
                context += `  Êìç‰ΩúÂÖÉÁ¥†: ${op.params.element_description}\n`;
            }
            context += '\n';
        });
        
        return context;
    }

    /**
     * ÊûÑÂª∫‰ªªÂä°ÊèêÁ§∫
     */
    buildTaskPrompt(task, elementList, pageState, stepCount) {
        let prompt = `ËØ∑‰∏∫‰ª•‰∏ã‰ªªÂä°ÈÄâÊã©ÊúÄ‰Ω≥Êìç‰ΩúÔºö

üéØ Áî®Êà∑‰ªªÂä°: "${task}"

üìä ÂΩìÂâçÁä∂ÊÄÅÔºö
- ÊâßË°åÊ≠•È™§: Á¨¨${stepCount}Ê≠•
- ÂΩìÂâçÈ°µÈù¢: ${pageState.title}
- È°µÈù¢URL: ${pageState.url}
- È°µÈù¢ÊòØÂê¶ÊúâÊñ∞ÂÜÖÂÆπ: ${pageState.hasNewContent ? 'ÊòØ' : 'Âê¶'}

üé® ÂΩìÂâçÈ°µÈù¢ÂèØ‰∫§‰∫íÂÖÉÁ¥†Ôºö`;

        if (elementList.length === 0) {
            prompt += '\n‚ö†Ô∏è Êú™Ê£ÄÊµãÂà∞ÂèØ‰∫§‰∫íÂÖÉÁ¥†ÔºåÂèØËÉΩÈúÄË¶ÅÁ≠âÂæÖÈ°µÈù¢Âä†ËΩΩÊàñÊªöÂä®È°µÈù¢„ÄÇ';
        } else {
            elementList.forEach((element, index) => {
                const colorEmoji = this.getColorEmoji(element.elementType);
                prompt += `\n${colorEmoji} ÁºñÂè∑${element.number}: ${element.description}`;
                prompt += `\n   üìç ‰ΩçÁΩÆ: ${element.position}`;
                prompt += `\n   üéØ Á±ªÂûã: ${element.interactionType}`;
                prompt += `\n   üìù ÊñáÊú¨: "${element.text}"`;
                prompt += `\n   üîß Áä∂ÊÄÅ: ${element.state}`;
                prompt += `\n   üíØ ÁΩÆ‰ø°Â∫¶: ${element.confidence}%`;
                prompt += `\n`;
            });
        }

        prompt += `\nüì∏ È°µÈù¢Êà™ÂõæÂàÜÊûêË¶ÅÊ±ÇÔºö
1. ‰ªîÁªÜËßÇÂØüÈ°µÈù¢Êà™Âõæ‰∏≠ÁöÑÂΩ©Ëâ≤Ê†áËÆ∞ÂíåÊï∞Â≠ó
2. ÂàÜÊûêÂΩìÂâçÈ°µÈù¢ÊòØÂê¶ÂèëÁîü‰∫ÜË∑≥ËΩ¨ÊàñÂÜÖÂÆπÂèòÂåñ
3. Ê†πÊçÆ‰ªªÂä°ËøõÂ∫¶Âà§Êñ≠‰∏ã‰∏ÄÊ≠•ÊúÄÂêàÈÄÇÁöÑÊìç‰Ωú
4. ‰ºòÂÖàÈÄâÊã©ÁΩÆ‰ø°Â∫¶È´ò„ÄÅÁä∂ÊÄÅËâØÂ•ΩÁöÑÂÖÉÁ¥†
5. Ê£ÄÊü•‰ªªÂä°ÊòØÂê¶Â∑≤ÁªèÂÆåÊàêÊàñÊé•ËøëÂÆåÊàê

ËØ∑ÈÄâÊã©ÊúÄÂêàÈÄÇÁöÑ‰∏ã‰∏ÄÊ≠•Êìç‰Ωú„ÄÇ`;

        return prompt;
    }

    /**
     * Ëé∑ÂèñÈ¢úËâ≤Ë°®ÊÉÖÁ¨¶Âè∑
     */
    getColorEmoji(elementType) {
        const emojiMap = {
            'button': 'üî¥',
            'input': 'üü†',
            'link': 'üü¢',
            'select': 'üîµ',
            'interactive': 'üü£',
            'custom': 'üü°'
        };
        return emojiMap[elementType] || '‚ö™';
    }

    /**
     * Ë∞ÉÁî®AI API
     */
    async callAI(messages) {
        try {
            const requestPayload = {
                model: 'gpt-4o-mini',
                messages: messages,
                tools: this.getToolDefinitions(),
                tool_choice: 'required',
                temperature: 0.1,
                max_tokens: 2000,
                timeout: this.decisionTimeout
            };

            const response = await fetch(this.apiEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify(requestPayload)
            });

            if (!response.ok) {
                throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return this.parseAIResponse(data);

        } catch (error) {
            console.error('‚ùå AI APIË∞ÉÁî®Â§±Ë¥•:', error.message);
            return null;
        }
    }

    /**
     * Ëé∑ÂèñÂ∑•ÂÖ∑ÂÆö‰πâ
     */
    getToolDefinitions() {
        return [
            {
                type: 'function',
                function: {
                    name: 'click_element',
                    description: 'ÁÇπÂáªÈ°µÈù¢‰∏äÁöÑÊåáÂÆöÂÖÉÁ¥†',
                    parameters: {
                        type: 'object',
                        properties: {
                            element_number: {
                                type: 'integer',
                                description: 'Ë¶ÅÁÇπÂáªÁöÑÂÖÉÁ¥†ÁºñÂè∑ÔºàÈ°µÈù¢‰∏äÁöÑÂΩ©Ëâ≤Êï∞Â≠óÊ†áËÆ∞Ôºâ'
                            },
                            element_type: {
                                type: 'string',
                                description: 'ÂÖÉÁ¥†Á±ªÂûã',
                                enum: ['button', 'input', 'link', 'select', 'interactive', 'custom']
                            },
                            element_description: {
                                type: 'string',
                                description: 'Ë¶ÅÁÇπÂáªÁöÑÂÖÉÁ¥†ÊèèËø∞'
                            },
                            reasoning: {
                                type: 'string',
                                description: 'ÈÄâÊã©Ëøô‰∏™Êìç‰ΩúÁöÑËØ¶ÁªÜÂéüÂõ†'
                            }
                        },
                        required: ['element_number', 'element_type', 'element_description', 'reasoning']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'input_text',
                    description: 'Âú®ÊåáÂÆöÁöÑËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•ÊñáÊú¨',
                    parameters: {
                        type: 'object',
                        properties: {
                            element_number: {
                                type: 'integer',
                                description: 'ËæìÂÖ•Ê°ÜÂÖÉÁ¥†ÁºñÂè∑'
                            },
                            element_type: {
                                type: 'string',
                                description: 'ÂÖÉÁ¥†Á±ªÂûãÔºåÈÄöÂ∏∏ÊòØinput',
                                enum: ['button', 'input', 'link', 'select', 'interactive', 'custom']
                            },
                            element_description: {
                                type: 'string',
                                description: 'ËæìÂÖ•Ê°ÜÂÖÉÁ¥†ÊèèËø∞'
                            },
                            text_content: {
                                type: 'string',
                                description: 'Ë¶ÅËæìÂÖ•ÁöÑÊñáÊú¨ÂÜÖÂÆπ'
                            },
                            reasoning: {
                                type: 'string',
                                description: 'ÈÄâÊã©Ëøô‰∏™Êìç‰ΩúÁöÑËØ¶ÁªÜÂéüÂõ†'
                            },
                            clear_before_input: {
                                type: 'boolean',
                                description: 'ÊòØÂê¶Âú®ËæìÂÖ•ÂâçÊ∏ÖÁ©∫Áé∞ÊúâÂÜÖÂÆπ',
                                default: true
                            }
                        },
                        required: ['element_number', 'element_type', 'element_description', 'text_content', 'reasoning']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'scroll_page',
                    description: 'ÊªöÂä®È°µÈù¢Êü•ÁúãÊõ¥Â§öÂÜÖÂÆπ',
                    parameters: {
                        type: 'object',
                        properties: {
                            direction: {
                                type: 'string',
                                enum: ['down', 'up', 'to_top', 'to_bottom'],
                                description: 'ÊªöÂä®ÊñπÂêë'
                            },
                            distance: {
                                type: 'integer',
                                description: 'ÊªöÂä®Ë∑ùÁ¶ªÔºàÂÉèÁ¥†Ôºâ',
                                default: 500
                            },
                            reasoning: {
                                type: 'string',
                                description: 'ÈÄâÊã©ÊªöÂä®ÁöÑÂéüÂõ†'
                            }
                        },
                        required: ['direction', 'reasoning']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'wait_for_page',
                    description: 'Á≠âÂæÖÈ°µÈù¢Âä†ËΩΩÊàñÂÜÖÂÆπÊõ¥Êñ∞',
                    parameters: {
                        type: 'object',
                        properties: {
                            wait_time: {
                                type: 'integer',
                                description: 'Á≠âÂæÖÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ',
                                default: 3000
                            },
                            reasoning: {
                                type: 'string',
                                description: 'Á≠âÂæÖÁöÑÂéüÂõ†'
                            }
                        },
                        required: ['reasoning']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'navigate_to_url',
                    description: 'ÂØºËà™Âà∞ÊåáÂÆöÁöÑURLÂú∞ÂùÄ',
                    parameters: {
                        type: 'object',
                        properties: {
                            url: {
                                type: 'string',
                                description: 'ÁõÆÊ†áURLÂú∞ÂùÄ'
                            },
                            reasoning: {
                                type: 'string',
                                description: 'ÂØºËà™ÁöÑÂéüÂõ†'
                            }
                        },
                        required: ['url', 'reasoning']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'complete_task',
                    description: 'Ê†áËÆ∞‰ªªÂä°Â∑≤ÂÆåÊàê',
                    parameters: {
                        type: 'object',
                        properties: {
                            completion_reason: {
                                type: 'string',
                                description: '‰ªªÂä°ÂÆåÊàêÁöÑËØ¶ÁªÜÂéüÂõ†'
                            },
                            final_result: {
                                type: 'string',
                                description: 'ÊúÄÁªàÁªìÊûúÊèèËø∞'
                            }
                        },
                        required: ['completion_reason', 'final_result']
                    }
                }
            }
        ];
    }

    /**
     * Ëß£ÊûêAIÂìçÂ∫î
     */
    parseAIResponse(apiResponse) {
        try {
            if (!apiResponse.choices || apiResponse.choices.length === 0) {
                throw new Error('APIÂìçÂ∫î‰∏≠Ê≤°ÊúâÈÄâÊã©È°π');
            }

            const choice = apiResponse.choices[0];
            const message = choice.message;

            if (!message.tool_calls || message.tool_calls.length === 0) {
                throw new Error('APIÂìçÂ∫î‰∏≠Ê≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®');
            }

            const toolCall = message.tool_calls[0];
            const functionName = toolCall.function.name;
            const functionArgs = JSON.parse(toolCall.function.arguments);

            return {
                tool: functionName,
                params: functionArgs,
                reasoning: functionArgs.reasoning || `AIÈÄâÊã©‰ΩøÁî®${functionName}Â∑•ÂÖ∑`,
                timestamp: Date.now()
            };

        } catch (error) {
            console.error('‚ùå Ëß£ÊûêAIÂìçÂ∫îÂ§±Ë¥•:', error.message);
            return null;
        }
    }

    /**
     * ËÆ∞ÂΩïÂÜ≥Á≠ñÂéÜÂè≤
     */
    recordDecision(decision, decisionTime) {
        this.decisionHistory.push({
            ...decision,
            decisionTime: decisionTime,
            timestamp: Date.now()
        });

        if (this.decisionHistory.length > this.maxHistorySize) {
            this.decisionHistory = this.decisionHistory.slice(-this.maxHistorySize);
        }
    }

    /**
     * Ëé∑ÂèñÂÜ≥Á≠ñÂéÜÂè≤
     */
    getDecisionHistory() {
        return this.decisionHistory.slice();
    }
}

/**
 * üéõÔ∏è Êô∫ËÉΩÊìç‰ΩúÊâßË°åÂô® - ÂÆåÂÖ®ÈáçÊûÑÁâà
 */
class SmartOperationExecutor {
    constructor(page, domDetector, pageStateMonitor) {
        this.page = page;
        this.domDetector = domDetector;
        this.pageStateMonitor = pageStateMonitor;
        this.operationHistory = [];
        this.maxHistorySize = 20;
    }

    /**
     * ÊâßË°åÊìç‰Ωú
     */
    async executeOperation(decision) {
        const operationStartTime = Date.now();
        
        try {
            console.log(`üîß ÊâßË°åÊìç‰Ωú: ${decision.tool}`);
            
            let result = null;
            
            switch (decision.tool) {
                case 'click_element':
                    result = await this.clickElement(decision.params);
                    break;
                case 'input_text':
                    result = await this.inputText(decision.params);
                    break;
                case 'scroll_page':
                    result = await this.scrollPage(decision.params);
                    break;
                case 'wait_for_page':
                    result = await this.waitForPage(decision.params);
                    break;
                case 'navigate_to_url':
                    result = await this.navigateToUrl(decision.params);
                    break;
                case 'complete_task':
                    result = await this.completeTask(decision.params);
                    break;
                default:
                    result = { success: false, error: `Êú™Áü•Êìç‰Ωú: ${decision.tool}` };
            }

            const operationTime = Date.now() - operationStartTime;
            
            // ËÆ∞ÂΩïÊìç‰ΩúÂéÜÂè≤
            this.recordOperation({
                tool: decision.tool,
                params: decision.params,
                result: result,
                operationTime: operationTime,
                timestamp: Date.now()
            });

            console.log(`${result.success ? '‚úÖ' : '‚ùå'} Êìç‰Ωú${result.success ? 'ÊàêÂäü' : 'Â§±Ë¥•'} (ËÄóÊó∂: ${operationTime}ms)`);
            
            return result;

        } catch (error) {
            console.error('‚ùå Êìç‰ΩúÊâßË°åÂºÇÂ∏∏:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ÁÇπÂáªÂÖÉÁ¥†
     */
    async clickElement(params) {
        try {
            const { element_number, element_type, element_description, reasoning } = params;
            
            console.log(`üéØ ÁÇπÂáªÂÖÉÁ¥† #${element_number}: ${element_description}`);
            console.log(`üí≠ Êìç‰ΩúÂéüÂõ†: ${reasoning}`);
            
            // Ëé∑ÂèñÂÖÉÁ¥†‰ø°ÊÅØ
            const elementInfo = this.domDetector.getElementById(element_number);
            if (!elementInfo) {
                return { success: false, error: `Êú™ÊâæÂà∞ÁºñÂè∑‰∏∫ ${element_number} ÁöÑÂÖÉÁ¥†` };
            }

            console.log(`üìç ÂÖÉÁ¥†‰ΩçÁΩÆ: (${elementInfo.position.centerX}, ${elementInfo.position.centerY})`);
            console.log(`üîß ÂÖÉÁ¥†Áä∂ÊÄÅ: ÂèØËßÅ=${elementInfo.state.isVisible}, ÂèØÁÇπÂáª=${elementInfo.state.isClickable}`);

            // Â§öÁ≠ñÁï•ÁÇπÂáª
            const strategies = [
                () => this.clickByAttribute(element_number),
                () => this.clickByPosition(elementInfo.position),
                () => this.clickBySelector(elementInfo),
                () => this.clickByText(elementInfo.text)
            ];

            for (let i = 0; i < strategies.length; i++) {
                try {
                    console.log(`üéØ Â∞ùËØïÁÇπÂáªÁ≠ñÁï•${i + 1}`);
                    const success = await strategies[i]();
                    
                    if (success) {
                        console.log(`‚úÖ ÁÇπÂáªÁ≠ñÁï•${i + 1}ÊàêÂäü`);
                        
                        // Á≠âÂæÖÈ°µÈù¢ÂìçÂ∫î
                        await this.sleep(2000);
                        
                        // Ê£ÄÊü•È°µÈù¢ÂèòÂåñ
                        await this.pageStateMonitor.updateCurrentState();
                        
                        return { success: true };
                    }
                    
                } catch (strategyError) {
                    console.warn(`‚ùå ÁÇπÂáªÁ≠ñÁï•${i + 1}Â§±Ë¥•: ${strategyError.message}`);
                    continue;
                }
            }

            return { success: false, error: 'ÊâÄÊúâÁÇπÂáªÁ≠ñÁï•ÈÉΩÂ§±Ë¥•‰∫Ü' };

        } catch (error) {
            console.error('‚ùå ÁÇπÂáªÂÖÉÁ¥†Â§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ÈÄöËøáÂ±ûÊÄßÁÇπÂáª
     */
    async clickByAttribute(elementNumber) {
        const locator = this.page.locator(`[data-ai-element-id="${elementNumber}"]`);
        const count = await locator.count();
        
        if (count > 0) {
            await locator.first().waitFor({ state: 'visible', timeout: 5000 });
            await locator.first().scrollIntoViewIfNeeded();
            await this.sleep(500);
            await locator.first().click({ timeout: 10000 });
            return true;
        }
        
        return false;
    }

    /**
     * ÈÄöËøá‰ΩçÁΩÆÁÇπÂáª
     */
    async clickByPosition(position) {
        const { centerX, centerY } = position;
        
        // ÊªöÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
        await this.page.evaluate((x, y) => {
            const targetX = Math.max(0, x - window.innerWidth / 2);
            const targetY = Math.max(0, y - window.innerHeight / 2);
            window.scrollTo({ left: targetX, top: targetY, behavior: 'smooth' });
        }, centerX, centerY);
        
        await this.sleep(1000);
        
        // È™åËØÅÂùêÊ†áÊòØÂê¶Âú®ËßÜÂè£ÂÜÖ
        const isInViewport = await this.page.evaluate((x, y) => {
            const rect = { left: x - 10, top: y - 10, right: x + 10, bottom: y + 10 };
            return rect.left >= 0 && rect.top >= 0 && 
                   rect.right <= window.innerWidth && rect.bottom <= window.innerHeight;
        }, centerX, centerY);
        
        if (isInViewport) {
            await this.page.mouse.click(centerX, centerY);
            return true;
        }
        
        return false;
    }

    /**
     * ÈÄöËøáÈÄâÊã©Âô®ÁÇπÂáª
     */
    async clickBySelector(elementInfo) {
        const selectors = [];
        
        if (elementInfo.attributes.id) {
            selectors.push(`#${elementInfo.attributes.id}`);
        }
        
        if (elementInfo.attributes.name) {
            selectors.push(`[name="${elementInfo.attributes.name}"]`);
        }
        
        if (elementInfo.attributes.className) {
            const mainClass = elementInfo.attributes.className.split(' ')[0];
            if (mainClass) {
                selectors.push(`.${mainClass}`);
            }
        }
        
        for (const selector of selectors) {
            try {
                const locator = this.page.locator(selector);
                const count = await locator.count();
                
                if (count > 0) {
                    const targetLocator = count > 1 ? locator.first() : locator;
                    await targetLocator.waitFor({ state: 'visible', timeout: 5000 });
                    await targetLocator.scrollIntoViewIfNeeded();
                    await this.sleep(500);
                    await targetLocator.click({ timeout: 10000 });
                    return true;
                }
            } catch (error) {
                continue;
            }
        }
        
        return false;
    }

    /**
     * ÈÄöËøáÊñáÊú¨ÁÇπÂáª
     */
    async clickByText(text) {
        if (!text || text.length < 3) return false;
        
        try {
            const locator = this.page.getByText(text, { exact: true });
            const count = await locator.count();
            
            if (count > 0) {
                await locator.first().waitFor({ state: 'visible', timeout: 5000 });
                await locator.first().scrollIntoViewIfNeeded();
                await this.sleep(500);
                await locator.first().click({ timeout: 10000 });
                return true;
            }
        } catch (error) {
            // Â∞ùËØïÈÉ®ÂàÜÂåπÈÖç
            try {
                const partialText = text.substring(0, Math.min(20, text.length));
                const locator = this.page.getByText(partialText);
                const count = await locator.count();
                
                if (count > 0) {
                    await locator.first().waitFor({ state: 'visible', timeout: 5000 });
                    await locator.first().scrollIntoViewIfNeeded();
                    await this.sleep(500);
                    await locator.first().click({ timeout: 10000 });
                    return true;
                }
            } catch (partialError) {
                return false;
            }
        }
        
        return false;
    }

    /**
     * ËæìÂÖ•ÊñáÊú¨
     */
    async inputText(params) {
        try {
            const { element_number, element_type, element_description, text_content, reasoning, clear_before_input } = params;
            
            console.log(`‚å®Ô∏è ËæìÂÖ•ÊñáÊú¨ #${element_number}: ${element_description} = "${text_content}"`);
            console.log(`üí≠ Êìç‰ΩúÂéüÂõ†: ${reasoning}`);
            
            // Ëé∑ÂèñÂÖÉÁ¥†‰ø°ÊÅØ
            const elementInfo = this.domDetector.getElementById(element_number);
            if (!elementInfo) {
                return { success: false, error: `Êú™ÊâæÂà∞ÁºñÂè∑‰∏∫ ${element_number} ÁöÑÂÖÉÁ¥†` };
            }

            // Â§öÁ≠ñÁï•ËæìÂÖ•
            const strategies = [
                () => this.inputByAttribute(element_number, text_content, clear_before_input),
                () => this.inputByPosition(elementInfo.position, text_content, clear_before_input),
                () => this.inputBySelector(elementInfo, text_content, clear_before_input)
            ];

            for (let i = 0; i < strategies.length; i++) {
                try {
                    console.log(`‚å®Ô∏è Â∞ùËØïËæìÂÖ•Á≠ñÁï•${i + 1}`);
                    const success = await strategies[i]();
                    
                    if (success) {
                        console.log(`‚úÖ ËæìÂÖ•Á≠ñÁï•${i + 1}ÊàêÂäü`);
                        await this.sleep(1000);
                        return { success: true };
                    }
                    
                } catch (strategyError) {
                    console.warn(`‚ùå ËæìÂÖ•Á≠ñÁï•${i + 1}Â§±Ë¥•: ${strategyError.message}`);
                    continue;
                }
            }

            return { success: false, error: 'ÊâÄÊúâËæìÂÖ•Á≠ñÁï•ÈÉΩÂ§±Ë¥•‰∫Ü' };

        } catch (error) {
            console.error('‚ùå ËæìÂÖ•ÊñáÊú¨Â§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ÈÄöËøáÂ±ûÊÄßËæìÂÖ•
     */
    async inputByAttribute(elementNumber, text, clearBefore) {
        const locator = this.page.locator(`[data-ai-element-id="${elementNumber}"]`);
        const count = await locator.count();
        
        if (count > 0) {
            const target = locator.first();
            await target.waitFor({ state: 'visible', timeout: 5000 });
            await target.scrollIntoViewIfNeeded();
            await this.sleep(500);
            
            if (clearBefore !== false) {
                await target.selectText().catch(() => {});
                await this.sleep(200);
            }
            
            await target.fill(text);
            return true;
        }
        
        return false;
    }

    /**
     * ÈÄöËøá‰ΩçÁΩÆËæìÂÖ•
     */
    async inputByPosition(position, text, clearBefore) {
        const { centerX, centerY } = position;
        
        // ÊªöÂä®Âπ∂ÁÇπÂáªËæìÂÖ•Ê°Ü
        await this.page.evaluate((x, y) => {
            window.scrollTo({
                left: Math.max(0, x - window.innerWidth / 2),
                top: Math.max(0, y - window.innerHeight / 2),
                behavior: 'smooth'
            });
        }, centerX, centerY);
        
        await this.sleep(1000);
        
        // ÁÇπÂáªËé∑ÂæóÁÑ¶ÁÇπ
        await this.page.mouse.click(centerX, centerY);
        await this.sleep(500);
        
        // Ê∏ÖÁ©∫ÂÜÖÂÆπ
        if (clearBefore !== false) {
            await this.page.keyboard.selectAll();
            await this.page.keyboard.press('Delete');
            await this.sleep(300);
        }
        
        // ËæìÂÖ•ÊñáÊú¨
        await this.page.keyboard.type(text, { delay: 50 });
        return true;
    }

    /**
     * ÈÄöËøáÈÄâÊã©Âô®ËæìÂÖ•
     */
    async inputBySelector(elementInfo, text, clearBefore) {
        const selectors = [];
        
        if (elementInfo.attributes.id) {
            selectors.push(`#${elementInfo.attributes.id}`);
        }
        
        if (elementInfo.attributes.name) {
            selectors.push(`[name="${elementInfo.attributes.name}"]`);
        }
        
        if (elementInfo.attributes.placeholder) {
            selectors.push(`[placeholder="${elementInfo.attributes.placeholder}"]`);
        }
        
        for (const selector of selectors) {
            try {
                const locator = this.page.locator(selector);
                const count = await locator.count();
                
                if (count > 0) {
                    const target = count > 1 ? locator.first() : locator;
                    await target.waitFor({ state: 'visible', timeout: 5000 });
                    await target.scrollIntoViewIfNeeded();
                    await this.sleep(500);
                    
                    if (clearBefore !== false) {
                        await target.selectText().catch(() => {});
                        await this.sleep(200);
                    }
                    
                    await target.fill(text);
                    return true;
                }
            } catch (error) {
                continue;
            }
        }
        
        return false;
    }

    /**
     * ÊªöÂä®È°µÈù¢
     */
    async scrollPage(params) {
        try {
            const { direction, distance = 500, reasoning } = params;
            
            console.log(`üìú ÊªöÂä®È°µÈù¢: ${direction} (${distance}px)`);
            console.log(`üí≠ ÊªöÂä®ÂéüÂõ†: ${reasoning}`);

            switch (direction) {
                case 'down':
                    await this.page.mouse.wheel(0, distance);
                    break;
                case 'up':
                    await this.page.mouse.wheel(0, -distance);
                    break;
                case 'to_top':
                    await this.page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));
                    break;
                case 'to_bottom':
                    await this.page.evaluate(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }));
                    break;
            }

            await this.sleep(2000);
            
            // Âº∫Âà∂ÈáçÊñ∞Ê£ÄÊµãÂÖÉÁ¥†
            await this.domDetector.detectElements(true);
            
            return { success: true };

        } catch (error) {
            console.error('‚ùå ÊªöÂä®È°µÈù¢Â§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * Á≠âÂæÖÈ°µÈù¢
     */
    async waitForPage(params) {
        try {
            const { wait_time = 3000, reasoning } = params;
            
            console.log(`‚è≥ Á≠âÂæÖÈ°µÈù¢: ${wait_time}ms`);
            console.log(`üí≠ Á≠âÂæÖÂéüÂõ†: ${reasoning}`);

            await this.sleep(wait_time);
            
            // Á≠âÂæÖÁΩëÁªúÁ©∫Èó≤
            await this.page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});
            
            // Êõ¥Êñ∞È°µÈù¢Áä∂ÊÄÅ
            await this.pageStateMonitor.updateCurrentState();
            
            // ÈáçÊñ∞Ê£ÄÊµãÂÖÉÁ¥†
            await this.domDetector.detectElements(true);
            
            return { success: true };

        } catch (error) {
            console.error('‚ùå Á≠âÂæÖÈ°µÈù¢Â§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ÂØºËà™Âà∞URL
     */
    async navigateToUrl(params) {
        try {
            const { url, reasoning } = params;
            
            console.log(`üåê ÂØºËà™Âà∞: ${url}`);
            console.log(`üí≠ ÂØºËà™ÂéüÂõ†: ${reasoning}`);

            await this.page.goto(url, { 
                waitUntil: 'networkidle', 
                timeout: 30000 
            });

            await this.sleep(3000);
            
            // Êõ¥Êñ∞È°µÈù¢Áä∂ÊÄÅ
            await this.pageStateMonitor.updateCurrentState();
            
            // ÈáçÊñ∞Ê£ÄÊµãÂÖÉÁ¥†
            await this.domDetector.detectElements(true);
            
            return { success: true };

        } catch (error) {
            console.error('‚ùå ÂØºËà™Â§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ÂÆåÊàê‰ªªÂä°
     */
    async completeTask(params) {
        try {
            const { completion_reason, final_result } = params;
            
            console.log(`üéâ ‰ªªÂä°ÂÆåÊàê`);
            console.log(`üí≠ ÂÆåÊàêÂéüÂõ†: ${completion_reason}`);
            console.log(`üìä ÊúÄÁªàÁªìÊûú: ${final_result}`);

            return { 
                success: true, 
                taskCompleted: true,
                completionReason: completion_reason,
                finalResult: final_result
            };

        } catch (error) {
            console.error('‚ùå Ê†áËÆ∞‰ªªÂä°ÂÆåÊàêÂ§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * ËÆ∞ÂΩïÊìç‰ΩúÂéÜÂè≤
     */
    recordOperation(operation) {
        this.operationHistory.push(operation);
        
        if (this.operationHistory.length > this.maxHistorySize) {
            this.operationHistory = this.operationHistory.slice(-this.maxHistorySize);
        }
    }

    /**
     * Ëé∑ÂèñÊìç‰ΩúÂéÜÂè≤
     */
    getOperationHistory() {
        return this.operationHistory.slice();
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * üéõÔ∏è ‰∏ªÊéßÂà∂Âô® - ÂÆåÂÖ®ÈáçÊûÑÁâà
 */
class MasterController {
    constructor() {
        // ÊµèËßàÂô®ÂÆû‰æã
        this.browser = null;
        this.context = null;
        this.currentPage = null;
        
        // Ê†∏ÂøÉÊ®°Âùó
        this.pageStateMonitor = null;
        this.tabManager = null;
        this.domDetector = null;
        this.aiDecisionEngine = null;
        this.operationExecutor = null;
        
        // ‰ªªÂä°Áä∂ÊÄÅ
        this.currentTask = {
            command: '',
            status: 'idle',
            currentStep: 0,
            maxSteps: 25,
            startTime: 0
        };
        
        // Á≥ªÁªüÁä∂ÊÄÅ
        this.isInitialized = false;
        this.operationStats = {
            totalSteps: 0,
            successfulSteps: 0,
            failedSteps: 0,
            pageNavigations: 0
        };
    }

    /**
     * ÂàùÂßãÂåñÁ≥ªÁªü
     */
    async initialize() {
        try {
            console.log('üöÄ ÂàùÂßãÂåñÊô∫ËÉΩÊµèËßàÂô®ÊéßÂà∂Á≥ªÁªü v15.0...');
            
            // ËøûÊé•ÊµèËßàÂô®
            if (!await this.connectBrowser()) {
                throw new Error('ÊµèËßàÂô®ËøûÊé•Â§±Ë¥•');
            }
            
            // ÂàùÂßãÂåñÊ†∏ÂøÉÊ®°Âùó
            await this.initializeModules();
            
            // ÂêØÂä®ÁõëÊéß
            await this.startMonitoring();
            
            // ÊâßË°åÂàùÂßãÊ£ÄÊµã
            await this.performInitialDetection();
            
            this.isInitialized = true;
            console.log('‚úÖ Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàêÔºÅ');
            
            return true;

        } catch (error) {
            console.error('‚ùå Á≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', error.message);
            return false;
        }
    }

    /**
     * ËøûÊé•ÊµèËßàÂô®
     */
    async connectBrowser() {
        try {
            console.log('üîó ËøûÊé•Âà∞EdgeË∞ÉËØïÁ´ØÂè£...');
            
            this.browser = await chromium.connectOverCDP('http://localhost:9222');
            const contexts = this.browser.contexts();
            
            if (contexts.length === 0) {
                throw new Error('Êú™ÊâæÂà∞ÊµèËßàÂô®‰∏ä‰∏ãÊñá');
            }
            
            this.context = contexts[0];
            const pages = this.context.pages();
            
            if (pages.length === 0) {
                throw new Error('Êú™ÊâæÂà∞ÊâìÂºÄÁöÑÈ°µÈù¢');
            }
            
            this.currentPage = pages[0];
            await this.currentPage.setViewportSize({ width: 1920, height: 1080 });
            
            console.log('‚úÖ ÊµèËßàÂô®ËøûÊé•ÊàêÂäü');
            console.log(`üìÑ ÂΩìÂâçÈ°µÈù¢: ${await this.currentPage.url()}`);
            
            return true;

        } catch (error) {
            console.error('‚ùå ÊµèËßàÂô®ËøûÊé•Â§±Ë¥•:', error.message);
            return false;
        }
    }

    /**
     * ÂàùÂßãÂåñÊ†∏ÂøÉÊ®°Âùó
     */
    async initializeModules() {
        console.log('üß† ÂàùÂßãÂåñÊ†∏ÂøÉÊ®°Âùó...');
        
        // È°µÈù¢Áä∂ÊÄÅÁõëÊéßÂô®
        this.pageStateMonitor = new PageStateMonitor(this.currentPage);
        console.log('‚úÖ È°µÈù¢Áä∂ÊÄÅÁõëÊéßÂô®Â∑≤ÂàõÂª∫');
        
        // Ê†áÁ≠æÈ°µÁÆ°ÁêÜÂô®
        this.tabManager = new SmartTabManager(this.browser, this.context);
        console.log('‚úÖ Êô∫ËÉΩÊ†áÁ≠æÈ°µÁÆ°ÁêÜÂô®Â∑≤ÂàõÂª∫');
        
        // DOMÊ£ÄÊµãÂô®
        this.domDetector = new AdvancedDOMDetector(this.currentPage, this.pageStateMonitor);
        console.log('‚úÖ È´òÁ∫ßDOMÊ£ÄÊµãÂô®Â∑≤ÂàõÂª∫');
        
        // AIÂÜ≥Á≠ñÂºïÊìé
        this.aiDecisionEngine = new EnhancedAIDecisionEngine(this.currentPage, this.pageStateMonitor);
        console.log('‚úÖ Â¢ûÂº∫AIÂÜ≥Á≠ñÂºïÊìéÂ∑≤ÂàõÂª∫');
        
        // Êìç‰ΩúÊâßË°åÂô®
        this.operationExecutor = new SmartOperationExecutor(this.currentPage, this.domDetector, this.pageStateMonitor);
        console.log('‚úÖ Êô∫ËÉΩÊìç‰ΩúÊâßË°åÂô®Â∑≤ÂàõÂª∫');
        
        // ËÆæÁΩÆÈ°µÈù¢Áä∂ÊÄÅÂèòÂåñÁõëÂê¨Âô®
        this.pageStateMonitor.addChangeListener(this.onPageStateChange.bind(this));
        
        console.log('üéØ ÊâÄÊúâÊ†∏ÂøÉÊ®°ÂùóÂ∑≤ÂàùÂßãÂåñ');
    }

    /**
     * ÂêØÂä®ÁõëÊéßÊúçÂä°
     */
    async startMonitoring() {
        console.log('üîÑ ÂêØÂä®ÁõëÊéßÊúçÂä°...');
        
        await this.pageStateMonitor.startMonitoring();
        await this.tabManager.startMonitoring();
        
        console.log('‚úÖ ÁõëÊéßÊúçÂä°Â∑≤ÂêØÂä®');
    }

    /**
     * ÊâßË°åÂàùÂßãÊ£ÄÊµã
     */
    async performInitialDetection() {
        console.log('üîç ÊâßË°åÂàùÂßãÈ°µÈù¢Ê£ÄÊµã...');
        
        // Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢ÂºïÁî®
        await this.updateCurrentPage();
        
        // Ê£ÄÊµãÈ°µÈù¢ÂÖÉÁ¥†
        const detection = await this.domDetector.detectElements();
        
        console.log(`üìä ÂàùÂßãÊ£ÄÊµãÂÆåÊàê: ${detection.totalElements}‰∏™ÂÖÉÁ¥†`);
        console.log(`üé® È°µÈù¢Ê†áËÆ∞Â∑≤Ê∑ªÂä†`);
    }

    /**
     * È°µÈù¢Áä∂ÊÄÅÂèòÂåñÂ§ÑÁêÜ
     */
    async onPageStateChange(oldState, newState, eventType) {
        try {
            console.log(`üîÑ Â§ÑÁêÜÈ°µÈù¢Áä∂ÊÄÅÂèòÂåñ: ${eventType}`);
            
            // Êõ¥Êñ∞ÁªüËÆ°
            if (oldState.url !== newState.url) {
                this.operationStats.pageNavigations++;
                console.log(`üåê È°µÈù¢ÂØºËà™ËÆ°Êï∞: ${this.operationStats.pageNavigations}`);
            }
            
            // Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢ÂºïÁî®
            await this.updateCurrentPage();
            
            // Âº∫Âà∂ÈáçÊñ∞Ê£ÄÊµãÂÖÉÁ¥†
            if (newState.hasNewContent) {
                console.log('üîÑ Ê£ÄÊµãÂà∞Êñ∞ÂÜÖÂÆπÔºåÈáçÊñ∞ÂàÜÊûêÈ°µÈù¢ÂÖÉÁ¥†...');
                await this.domDetector.detectElements(true);
            }
            
        } catch (error) {
            console.error('‚ùå Â§ÑÁêÜÈ°µÈù¢Áä∂ÊÄÅÂèòÂåñÂ§±Ë¥•:', error.message);
        }
    }

    /**
     * Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢ÂºïÁî®
     */
    async updateCurrentPage() {
        try {
            const activeTab = this.tabManager.getActiveTab();
            
            if (activeTab && activeTab !== this.currentPage) {
                console.log('üîÑ ÂàáÊç¢Âà∞Êñ∞ÁöÑÊ¥ªÂä®È°µÈù¢');
                
                this.currentPage = activeTab;
                
                // Êõ¥Êñ∞ÊâÄÊúâÊ®°ÂùóÁöÑÈ°µÈù¢ÂºïÁî®
                this.pageStateMonitor.page = this.currentPage;
                this.domDetector.page = this.currentPage;
                this.aiDecisionEngine.page = this.currentPage;
                this.operationExecutor.page = this.currentPage;
                
                console.log(`üìÑ ÂΩìÂâçÈ°µÈù¢Â∑≤Êõ¥Êñ∞: ${await this.currentPage.url()}`);
            }
            
        } catch (error) {
            console.error('‚ùå Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢Â§±Ë¥•:', error.message);
        }
    }

    /**
     * ÊâßË°å‰ªªÂä°
     */
    async executeTask(command) {
        try {
            console.log(`\nüéØ ÂºÄÂßãÊâßË°å‰ªªÂä°: "${command}"`);
            
            // ÂàùÂßãÂåñ‰ªªÂä°
            this.initializeTask(command);
            
            let taskCompleted = false;
            let consecutiveFailures = 0;
            const maxConsecutiveFailures = 3;
            
            while (this.currentTask.currentStep < this.currentTask.maxSteps && 
                   this.currentTask.status === 'running' && 
                   !taskCompleted) {
                
                this.currentTask.currentStep++;
                console.log(`\nüîÑ ÊâßË°åÊ≠•È™§ ${this.currentTask.currentStep}/${this.currentTask.maxSteps}`);
                
                try {
                    // ÊâßË°åÂçïÊ≠•Êìç‰Ωú
                    const stepResult = await this.executeStep(command);
                    
                    if (stepResult.success) {
                        consecutiveFailures = 0;
                        this.operationStats.successfulSteps++;
                        
                        // Ê£ÄÊü•‰ªªÂä°ÂÆåÊàê
                        if (stepResult.taskCompleted) {
                            console.log('üéâ AIÂà§Êñ≠‰ªªÂä°Â∑≤ÂÆåÊàêÔºÅ');
                            taskCompleted = true;
                            break;
                        }
                        
                    } else {
                        consecutiveFailures++;
                        this.operationStats.failedSteps++;
                        
                        console.warn(`‚ö†Ô∏è Ê≠•È™§Â§±Ë¥• (ËøûÁª≠Â§±Ë¥•: ${consecutiveFailures}/${maxConsecutiveFailures})`);
                        
                        if (consecutiveFailures >= maxConsecutiveFailures) {
                            console.error('‚ùå ËøûÁª≠Â§±Ë¥•Ê¨°Êï∞ËøáÂ§öÔºå‰ªªÂä°ÁªàÊ≠¢');
                            this.currentTask.status = 'failed';
                            break;
                        }
                    }
                    
                    // Ê≠•È™§Èó¥Á≠âÂæÖ
                    await this.sleep(1500);
                    
                } catch (stepError) {
                    console.error(`‚ùå Ê≠•È™§ ${this.currentTask.currentStep} ÂºÇÂ∏∏:`, stepError.message);
                    consecutiveFailures++;
                    this.operationStats.failedSteps++;
                    
                    if (consecutiveFailures >= maxConsecutiveFailures) {
                        this.currentTask.status = 'failed';
                        break;
                    }
                }
            }
            
            // Â§ÑÁêÜ‰ªªÂä°ÁªìÊûú
            return this.handleTaskCompletion(taskCompleted);
            
        } catch (error) {
            console.error('‚ùå ‰ªªÂä°ÊâßË°åÂºÇÂ∏∏:', error.message);
            this.currentTask.status = 'failed';
            return false;
        }
    }

    /**
     * ÂàùÂßãÂåñ‰ªªÂä°
     */
    initializeTask(command) {
        this.currentTask = {
            command: command,
            status: 'running',
            currentStep: 0,
            maxSteps: 25,
            startTime: Date.now()
        };
        
        this.operationStats = {
            totalSteps: 0,
            successfulSteps: 0,
            failedSteps: 0,
            pageNavigations: 0
        };
        
        console.log(`üìã ‰ªªÂä°Â∑≤ÂàùÂßãÂåñÔºåÊúÄÂ§ßÊ≠•È™§: ${this.currentTask.maxSteps}`);
    }

    /**
     * ÊâßË°åÂçï‰∏™Ê≠•È™§
     */
    async executeStep(command) {
        const stepStartTime = Date.now();
        
        try {
            console.log('üîç ÂºÄÂßãÊ≠•È™§ÂàÜÊûê...');
            
            // Á°Æ‰øù‰ΩøÁî®ÊúÄÊñ∞ÁöÑÈ°µÈù¢
            await this.updateCurrentPage();
            
            // Ëé∑ÂèñÂΩìÂâçÈ°µÈù¢Áä∂ÊÄÅ
            const pageState = this.pageStateMonitor.getCurrentState();
            
            // Ê£ÄÊµãÈ°µÈù¢ÂÖÉÁ¥†
            const detection = await this.domDetector.detectElements();
            const elementList = this.domDetector.getElementsForAI(15);
            
            console.log(`üìä È°µÈù¢ÂàÜÊûê: ${elementList.length}‰∏™ÂèØÁî®ÂÖÉÁ¥†`);
            
            // AIÂÜ≥Á≠ñ
            const operationHistory = this.operationExecutor.getOperationHistory();
            const decision = await this.aiDecisionEngine.makeDecision(
                command, elementList, pageState, this.currentTask.currentStep, operationHistory
            );
            
            if (!decision) {
                return { success: false, error: 'AIÂÜ≥Á≠ñÂ§±Ë¥•' };
            }
            
            console.log(`üéØ AIÂÜ≥Á≠ñ: ${decision.tool}`);
            if (decision.params.element_number) {
                console.log(`üîç ÁõÆÊ†áÂÖÉÁ¥†: #${decision.params.element_number}`);
            }
            
            // ÊâßË°åÊìç‰Ωú
            const operationResult = await this.operationExecutor.executeOperation(decision);
            
            const stepTime = Date.now() - stepStartTime;
            this.operationStats.totalSteps++;
            
            console.log(`‚è±Ô∏è Ê≠•È™§ËÄóÊó∂: ${stepTime}ms`);
            
            return {
                success: operationResult.success,
                taskCompleted: operationResult.taskCompleted || false,
                error: operationResult.error,
                stepTime: stepTime
            };
            
        } catch (error) {
            console.error('‚ùå Ê≠•È™§ÊâßË°åÂ§±Ë¥•:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * Â§ÑÁêÜ‰ªªÂä°ÂÆåÊàê
     */
    handleTaskCompletion(taskCompleted) {
        const duration = ((Date.now() - this.currentTask.startTime) / 1000).toFixed(1);
        
        if (taskCompleted || this.currentTask.status === 'running') {
            this.currentTask.status = 'completed';
            console.log(`\nüéâ ‰ªªÂä°ÊâßË°åÊàêÂäüÔºÅ`);
        } else {
            console.log(`\nüòî ‰ªªÂä°ÊâßË°åÂ§±Ë¥•`);
        }
        
        console.log(`‚è±Ô∏è ÊÄªËÄóÊó∂: ${duration}Áßí`);
        console.log(`üìä Êìç‰ΩúÁªüËÆ°:`);
        console.log(`  - ÊÄªÊ≠•È™§: ${this.operationStats.totalSteps}`);
        console.log(`  - ÊàêÂäüÊ≠•È™§: ${this.operationStats.successfulSteps}`);
        console.log(`  - Â§±Ë¥•Ê≠•È™§: ${this.operationStats.failedSteps}`);
        console.log(`  - È°µÈù¢ÂØºËà™: ${this.operationStats.pageNavigations}`);
        console.log(`  - ÊàêÂäüÁéá: ${Math.round((this.operationStats.successfulSteps / Math.max(1, this.operationStats.totalSteps)) * 100)}%`);
        
        return this.currentTask.status === 'completed';
    }

    /**
     * Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅ
     */
    getSystemStatus() {
        try {
            const pageState = this.pageStateMonitor ? this.pageStateMonitor.getCurrentState() : {};
            const elementList = this.domDetector ? this.domDetector.getElementsForAI(5) : [];
            const detectionInfo = this.domDetector ? this.domDetector.getDetectionInfo() : {};
            const tabsInfo = this.tabManager ? this.tabManager.getAllTabsInfo() : [];
            
            return {
                system: {
                    version: 'v15.0',
                    initialized: this.isInitialized,
                    currentUrl: pageState.url || 'unknown'
                },
                task: {
                    command: this.currentTask.command,
                    status: this.currentTask.status,
                    currentStep: this.currentTask.currentStep,
                    maxSteps: this.currentTask.maxSteps,
                    progress: (this.currentTask.currentStep / this.currentTask.maxSteps) * 100
                },
                page: {
                    title: pageState.title || 'unknown',
                    hasNewContent: pageState.hasNewContent || false,
                    isLoading: pageState.isLoading || false,
                    elementsDetected: detectionInfo.totalElements || 0,
                    elementsVisible: elementList.length
                },
                tabs: {
                    totalTabs: tabsInfo.length,
                    activeTab: this.tabManager ? (this.tabManager.getActiveTab() === this.currentPage) : false
                },
                stats: this.operationStats
            };
            
        } catch (error) {
            console.error('‚ùå Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅÂ§±Ë¥•:', error.message);
            return { error: error.message };
        }
    }

    /**
     * Ê∏ÖÁêÜËµÑÊ∫ê
     */
    async cleanup() {
        try {
            console.log('üßπ Ê∏ÖÁêÜÁ≥ªÁªüËµÑÊ∫ê...');
            
            if (this.pageStateMonitor) {
                this.pageStateMonitor.stopMonitoring();
            }
            
            if (this.tabManager) {
                this.tabManager.stopMonitoring();
            }
            
            if (this.domDetector) {
                await this.domDetector.clearMarkers();
            }
            
            console.log('‚úÖ ËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê');
            
        } catch (error) {
            console.error('‚ùå ËµÑÊ∫êÊ∏ÖÁêÜÂ§±Ë¥•:', error.message);
        }
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/**
 * üì± ÁªàÁ´ØÁïåÈù¢ - ÈáçÊûÑÁâà
 */
class TerminalInterface {
    constructor() {
        this.controller = null;
        this.rl = null;
        this.isRunning = false;
        this.sessionStats = {
            startTime: Date.now(),
            commandsExecuted: 0,
            successfulCommands: 0
        };
    }

    /**
     * ÂêØÂä®ÁªàÁ´ØÁïåÈù¢
     */
    async start() {
        try {
            console.log('AIÂ¢ûÂº∫Êô∫ËÉΩÊµèËßàÂô®ÊéßÂà∂Á≥ªÁªü');
            console.log('='.repeat(80));
            
            // ÂàùÂßãÂåñÊéßÂà∂Âô®
            this.controller = new MasterController();
            const initSuccess = await this.controller.initialize();
            
            if (!initSuccess) {
                console.log('‚ùå Á≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•');
                console.log('üí° ËØ∑Á°Æ‰øùEdgeÊµèËßàÂô®Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãËøêË°åÔºö');
                console.log('   "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe" --remote-debugging-port=9222');
                return;
            }
            
            // ÂàõÂª∫ÁªàÁ´ØÁïåÈù¢
            this.rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
                prompt: 'v15.0> '
            });
            
            this.isRunning = true;
            
            this.showWelcomeMessage();
            await this.runInteractiveLoop();
            
        } catch (error) {
            console.error('‚ùå Á≥ªÁªüÂêØÂä®Â§±Ë¥•:', error.message);
            process.exit(1);
        }
    }

    /**
     * ÊòæÁ§∫Ê¨¢ËøéÊ∂àÊÅØ
     */
    showWelcomeMessage() {
        console.log('\nüéØ Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàêÔºÅ');
        console.log('üí° ËæìÂÖ•‰ªªÂä°ÊèèËø∞ÔºåAIÂ∞ÜÊô∫ËÉΩÊâßË°å');
        console.log('üìñ ËæìÂÖ• "help" Êü•ÁúãÂ∏ÆÂä©Ôºå"exit" ÈÄÄÂá∫Á®ãÂ∫è');
        console.log('\nüé® Â¢ûÂº∫ÁâπÊÄßÔºö');
        console.log('   ‚úÖ Êô∫ËÉΩÈ°µÈù¢Ë∑≥ËΩ¨Ê£ÄÊµã   ‚úÖ ÂÆûÊó∂Áä∂ÊÄÅÁõëÊéß');
        console.log('   ‚úÖ Â§öÁ≠ñÁï•ÂÖÉÁ¥†ÂÆö‰Ωç     ‚úÖ Ëá™Âä®Ê†áÁ≠æÈ°µÁÆ°ÁêÜ');
        console.log('   ‚úÖ AIÂ§öÊ®°ÊÄÅÂÜ≥Á≠ñ       ‚úÖ Âä®ÊÄÅÁºìÂ≠ò‰ºòÂåñ');
        console.log('='.repeat(80));
    }

    /**
     * ËøêË°å‰∫§‰∫íÂæ™ÁéØ
     */
    async runInteractiveLoop() {
        this.rl.prompt();
        
        this.rl.on('line', async (input) => {
            const command = input.trim();
            
            if (!command) {
                this.rl.prompt();
                return;
            }
            
            this.sessionStats.commandsExecuted++;
            
            if (this.isSystemCommand(command)) {
                await this.handleSystemCommand(command);
            } else {
                await this.executeUserTask(command);
            }
            
            if (this.isRunning) {
                this.rl.prompt();
            }
        });
        
        this.rl.on('close', () => {
            this.handleExit();
        });
    }

    /**
     * Ê£ÄÊü•Á≥ªÁªüÂëΩ‰ª§
     */
    isSystemCommand(command) {
        const systemCommands = ['status', 'refresh', 'clear', 'help', 'exit', 'quit'];
        return systemCommands.includes(command.toLowerCase());
    }

    /**
     * Â§ÑÁêÜÁ≥ªÁªüÂëΩ‰ª§
     */
    async handleSystemCommand(command) {
        try {
            switch (command.toLowerCase()) {
                case 'status':
                    this.showSystemStatus();
                    break;
                case 'refresh':
                    await this.refreshSystem();
                    break;
                case 'clear':
                    await this.clearMarkers();
                    break;
                case 'help':
                    this.showHelp();
                    break;
                case 'exit':
                case 'quit':
                    this.handleExit();
                    break;
                default:
                    console.log('‚ùå Êú™Áü•Á≥ªÁªüÂëΩ‰ª§');
            }
        } catch (error) {
            console.error('‚ùå Á≥ªÁªüÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•:', error.message);
        }
    }

    /**
     * ÊâßË°åÁî®Êà∑‰ªªÂä°
     */
    async executeUserTask(command) {
        const taskStartTime = Date.now();
        
        try {
            console.log(`\nüéØ ÂºÄÂßãÊâßË°å‰ªªÂä°: "${command}"`);
            console.log(`‚è±Ô∏è ÂºÄÂßãÊó∂Èó¥: ${new Date().toLocaleTimeString()}`);
            
            const success = await this.controller.executeTask(command);
            
            const duration = ((Date.now() - taskStartTime) / 1000).toFixed(1);
            
            if (success) {
                this.sessionStats.successfulCommands++;
                console.log(`\nüéâ ‰ªªÂä°ÊâßË°åÊàêÂäüÔºÅËÄóÊó∂: ${duration}Áßí`);
            } else {
                console.log(`\nüòî ‰ªªÂä°ÊâßË°åÂ§±Ë¥•ÔºåËÄóÊó∂: ${duration}Áßí`);
                console.log(`üí° Âª∫ËÆÆ: Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÂ∞ùËØïÈáçÊñ∞Ë°®Ëø∞‰ªªÂä°`);
            }
            
            const successRate = Math.round((this.sessionStats.successfulCommands / this.sessionStats.commandsExecuted) * 100);
            console.log(`üìä ‰ºöËØùÊàêÂäüÁéá: ${successRate}%`);
            
        } catch (error) {
            console.error('‚ùå ‰ªªÂä°ÊâßË°åÂºÇÂ∏∏:', error.message);
        }
    }

    /**
     * ÊòæÁ§∫Á≥ªÁªüÁä∂ÊÄÅ
     */
    showSystemStatus() {
        try {
            console.log('\nüìä Á≥ªÁªüÁä∂ÊÄÅÊä•Âëä v15.0');
            console.log('='.repeat(60));
            
            const status = this.controller.getSystemStatus();
            
            console.log('üîß Á≥ªÁªü‰ø°ÊÅØ:');
            console.log(`  ÁâàÊú¨: ${status.system.version}`);
            console.log(`  ÂàùÂßãÂåñÁä∂ÊÄÅ: ${status.system.initialized ? '‚úÖ Â∑≤ÂÆåÊàê' : '‚ùå Êú™ÂÆåÊàê'}`);
            console.log(`  ÂΩìÂâçÈ°µÈù¢: ${status.system.currentUrl}`);
            
            console.log('\nüéØ ‰ªªÂä°Áä∂ÊÄÅ:');
            console.log(`  ÂΩìÂâç‰ªªÂä°: ${status.task.command || 'Êó†'}`);
            console.log(`  ‰ªªÂä°Áä∂ÊÄÅ: ${status.task.status}`);
            console.log(`  ÊâßË°åËøõÂ∫¶: ${status.task.progress.toFixed(1)}%`);
            console.log(`  ÂΩìÂâçÊ≠•È™§: ${status.task.currentStep}/${status.task.maxSteps}`);
            
            console.log('\nüìÑ È°µÈù¢‰ø°ÊÅØ:');
            console.log(`  È°µÈù¢Ê†áÈ¢ò: ${status.page.title}`);
            console.log(`  ÊúâÊñ∞ÂÜÖÂÆπ: ${status.page.hasNewContent ? '‚úÖ ÊòØ' : '‚ùå Âê¶'}`);
            console.log(`  Ê≠£Âú®Âä†ËΩΩ: ${status.page.isLoading ? '‚úÖ ÊòØ' : '‚ùå Âê¶'}`);
            console.log(`  Ê£ÄÊµãÂÖÉÁ¥†: ${status.page.elementsDetected}‰∏™`);
            console.log(`  ÂèØËßÅÂÖÉÁ¥†: ${status.page.elementsVisible}‰∏™`);
            
            console.log('\nüóÇÔ∏è Ê†áÁ≠æÈ°µ‰ø°ÊÅØ:');
            console.log(`  ÊÄªÊ†áÁ≠æÈ°µ: ${status.tabs.totalTabs}‰∏™`);
            console.log(`  Ê¥ªÂä®È°µÈù¢: ${status.tabs.activeTab ? '‚úÖ Ê≠£Á°Æ' : '‚ö†Ô∏è ÈúÄÂàáÊç¢'}`);
            
            console.log('\nüìä Êìç‰ΩúÁªüËÆ°:');
            console.log(`  ÊÄªÊ≠•È™§: ${status.stats.totalSteps}`);
            console.log(`  ÊàêÂäüÊ≠•È™§: ${status.stats.successfulSteps}`);
            console.log(`  Â§±Ë¥•Ê≠•È™§: ${status.stats.failedSteps}`);
            console.log(`  È°µÈù¢ÂØºËà™: ${status.stats.pageNavigations}`);
            
            const sessionDuration = ((Date.now() - this.sessionStats.startTime) / 60000).toFixed(1);
            console.log('\nüìä ‰ºöËØùÁªüËÆ°:');
            console.log(`  ‰ºöËØùÊó∂Èïø: ${sessionDuration}ÂàÜÈíü`);
            console.log(`  ÊâßË°åÂëΩ‰ª§: ${this.sessionStats.commandsExecuted}‰∏™`);
            console.log(`  ÊàêÂäüÂëΩ‰ª§: ${this.sessionStats.successfulCommands}‰∏™`);
            
            console.log('\n='.repeat(60));
            
        } catch (error) {
            console.error('‚ùå Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅÂ§±Ë¥•:', error.message);
        }
    }

    /**
     * Âà∑Êñ∞Á≥ªÁªü
     */
    async refreshSystem() {
        try {
            console.log('\nüîÑ Âà∑Êñ∞Á≥ªÁªüÁä∂ÊÄÅ...');
            
            await this.controller.updateCurrentPage();
            await this.controller.domDetector.detectElements(true);
            
            console.log('‚úÖ Á≥ªÁªüÂà∑Êñ∞ÂÆåÊàê');
            
        } catch (error) {
            console.error('‚ùå Á≥ªÁªüÂà∑Êñ∞Â§±Ë¥•:', error.message);
        }
    }

    /**
     * Ê∏ÖÈô§Ê†áËÆ∞
     */
    async clearMarkers() {
        try {
            console.log('\nüßπ Ê∏ÖÈô§È°µÈù¢Ê†áËÆ∞...');
            
            await this.controller.domDetector.clearMarkers();
            
            console.log('‚úÖ È°µÈù¢Ê†áËÆ∞Â∑≤Ê∏ÖÈô§');
            
        } catch (error) {
            console.error('‚ùå Ê∏ÖÈô§Ê†áËÆ∞Â§±Ë¥•:', error.message);
        }
    }

    /**
     * ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ
     */
    showHelp() {
        console.log('Êô∫ËÉΩÊµèËßàÂô®ÊéßÂà∂Á≥ªÁªüÂ∏ÆÂä©');
        console.log('='.repeat(70));
        
        console.log('\nüöÄ v15.0 Ê†∏ÂøÉÁâπÊÄß:');
        console.log('  ‚úÖ Êô∫ËÉΩÈ°µÈù¢Ë∑≥ËΩ¨Ê£ÄÊµã - ÂÆûÊó∂ÊÑüÁü•È°µÈù¢ÂèòÂåñ');
        console.log('  ‚úÖ È´òÁ∫ßDOMÂÖÉÁ¥†Ê£ÄÊµã - Â§öÁ≠ñÁï•ÂÖÉÁ¥†ÂÆö‰Ωç');
        console.log('  ‚úÖ AIÂ§öÊ®°ÊÄÅÂÜ≥Á≠ñÂºïÊìé - ÁªìÂêàËßÜËßâÂíåÊñáÊú¨ÂàÜÊûê');
        console.log('  ‚úÖ Êô∫ËÉΩÊ†áÁ≠æÈ°µÁÆ°ÁêÜ - Ëá™Âä®ÂàáÊç¢ÊúÄ‰Ω≥È°µÈù¢');
        console.log('  ‚úÖ Âä®ÊÄÅÁºìÂ≠ò‰ºòÂåñ - ÊèêÂçáÊ£ÄÊµãÊïàÁéá');
        console.log('  ‚úÖ ÂÆûÊó∂Áä∂ÊÄÅÁõëÊéß - ÂÖ®Èù¢Á≥ªÁªüÁõëÊéß');
        
        console.log('\nüé® ÂÖÉÁ¥†Ê†áËÆ∞Á≥ªÁªü:');
        console.log('  üî¥ Á∫¢Ëâ≤ - ÊåâÈíÆÁ±ªÂÖÉÁ¥† (button)');
        console.log('  üü† Ê©ôËâ≤ - ËæìÂÖ•Ê°ÜÂÖÉÁ¥† (input)');
        console.log('  üü¢ ÁªøËâ≤ - ÈìæÊé•ÂÖÉÁ¥† (link)');
        console.log('  üîµ ËìùËâ≤ - ÈÄâÊã©Êéß‰ª∂ (select)');
        console.log('  üü£ Á¥´Ëâ≤ - ‰∫§‰∫íÂÖÉÁ¥† (interactive)');
        console.log('  üü° ÈªÑËâ≤ - Ëá™ÂÆö‰πâÂÖÉÁ¥† (custom)');
        
        console.log('\nüìã ‰ªªÂä°Á§∫‰æã:');
        console.log('  ‚Ä¢ "Ê∑òÂÆùÊêúÁ¥¢‰π∞‰∏™ÊâãÊú∫" - Êô∫ËÉΩÊêúÁ¥¢ÂíåÂïÜÂìÅÊµèËßà');
        console.log('  ‚Ä¢ "Â∏ÆÊàëÁôªÂΩïË¥¶Êà∑" - Ëá™Âä®Â°´ÂÜôÁôªÂΩïË°®Âçï');
        console.log('  ‚Ä¢ "Êü•ÁúãÂïÜÂìÅËØ¶ÊÉÖÂπ∂Âä†Ë¥≠Áâ©ËΩ¶" - Â§çÊùÇË¥≠Áâ©ÊµÅÁ®ã');
        console.log('  ‚Ä¢ "ÊêúÁ¥¢Êñ∞ÈóªÂÖ≥‰∫éAIÂèëÂ±ï" - ‰ø°ÊÅØÊ£ÄÁ¥¢‰ªªÂä°');
        
        console.log('\nüîß Á≥ªÁªüÂëΩ‰ª§:');
        console.log('  ‚Ä¢ status  - ÊòæÁ§∫ËØ¶ÁªÜÁ≥ªÁªüÁä∂ÊÄÅ');
        console.log('  ‚Ä¢ refresh - Âà∑Êñ∞È°µÈù¢Áä∂ÊÄÅÂíåÂÖÉÁ¥†Ê£ÄÊµã');
        console.log('  ‚Ä¢ clear   - Ê∏ÖÈô§È°µÈù¢‰∏äÁöÑÂèØËßÜÂåñÊ†áËÆ∞');
        console.log('  ‚Ä¢ help    - ÊòæÁ§∫Ê≠§Â∏ÆÂä©‰ø°ÊÅØ');
        console.log('  ‚Ä¢ exit    - ÂÆâÂÖ®ÈÄÄÂá∫Á®ãÂ∫è');
        
        console.log('\nüí° ‰ΩøÁî®ÊäÄÂ∑ß:');
        console.log('  ‚Ä¢ Á≥ªÁªü‰ºöËá™Âä®Ê£ÄÊµãÈ°µÈù¢Ë∑≥ËΩ¨ÂíåÊñ∞ÂÜÖÂÆπ');
        console.log('  ‚Ä¢ AIÂü∫‰∫éÊà™ÂõæÂíåÂÖÉÁ¥†‰ø°ÊÅØÂÅöÂá∫Êô∫ËÉΩÂÜ≥Á≠ñ');
        console.log('  ‚Ä¢ ÊîØÊåÅÂ§çÊùÇÁöÑÂ§öÊ≠•È™§‰ªªÂä°ÊâßË°å');
        console.log('  ‚Ä¢ Ëá™Âä®Â§ÑÁêÜÈ°µÈù¢Âä†ËΩΩÂíåÂÖÉÁ¥†Á≠âÂæÖ');
        
        console.log('\n='.repeat(70));
    }

    /**
     * ÈÄÄÂá∫Â§ÑÁêÜ
     */
    handleExit() {
        try {
            console.log('\nüëã Ê≠£Âú®ÂÆâÂÖ®ÈÄÄÂá∫Á≥ªÁªü...');
            
            const sessionDuration = ((Date.now() - this.sessionStats.startTime) / 60000).toFixed(1);
            
            console.log('\nüìä ‰ºöËØùÊÄªÁªì:');
            console.log(`  ‰ºöËØùÊó∂Èïø: ${sessionDuration}ÂàÜÈíü`);
            console.log(`  ÊâßË°åÂëΩ‰ª§: ${this.sessionStats.commandsExecuted}‰∏™`);
            console.log(`  ÊàêÂäüÂëΩ‰ª§: ${this.sessionStats.successfulCommands}‰∏™`);
            console.log(`  ÊàêÂäüÁéá: ${Math.round((this.sessionStats.successfulCommands / Math.max(1, this.sessionStats.commandsExecuted)) * 100)}%`);
            
            // Ê∏ÖÁêÜËµÑÊ∫ê
            if (this.controller) {
                this.controller.cleanup();
            }
            
            this.isRunning = false;
            
            if (this.rl) {
                this.rl.close();
            }
            
            process.exit(0);
            
        } catch (error) {
            console.error('‚ùå ÈÄÄÂá∫ËøáÁ®ãÈîôËØØ:', error.message);
            process.exit(1);
        }
    }
}


(async function main() {
    console.log('ÂêØÂä®AIÂ¢ûÂº∫Êô∫ËÉΩÊµèËßàÂô®ÊéßÂà∂Á≥ªÁªü...');
    
    const terminal = new TerminalInterface();
    await terminal.start();
})().catch(error => {
    console.error('ÂêØÂä®Â§±Ë¥•:', error.message);
    console.error('ËØ∑Á°Æ‰øùEdgeÊµèËßàÂô®Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãËøêË°åÔºö');
    console.error('   "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe" --remote-debugging-port=9222');
    process.exit(1);
});

// ÂØºÂá∫Ê®°Âùó
module.exports = {
    MasterController,
    PageStateMonitor,
    SmartTabManager,
    AdvancedDOMDetector,
    EnhancedAIDecisionEngine,
    SmartOperationExecutor,
    TerminalInterface,
    ElementTypes
};